%option lang = "C++"
%option namespace = "Ast"


%decls%{
    #include <memory>  // Necesario para shared_ptr
    #include <string>
    #include <iostream>
    #include <sstream>
    #include <unordered_map>
    #include <vector>
    #include <optional>
    
    using string_t = std::string;
    using symbol_table = std::unordered_map<std::string, int>;
    using arguments = std::vector<int>;
    
    // Declarar primero ArrayVariables_Table
    using ArrayVariables_Table = std::unordered_map<
    std::string, 
    std::shared_ptr<std::vector<std::optional<int>>> // Mantener consistencia
    >;


    namespace Ast {
        class Node;
    }
    
    // Luego Method_Table que lo referencia
    using Method_Table = std::unordered_map<std::string, Ast::Node*>;

    struct CodegenResult{
        std::string code;
        std::string place;
    };
%}


%{
    #include "ExprAst.hpp"
    #include "exceptions.hpp"

    

    std::string newVariable(){
        static int index = 0;

        return "t" + std::to_string(index++);
    }

    std::string newLabel(){
        static int index = 0;

        return "L" + std::to_string(index++);
    }




%}

%node Node %abstract %typedef
%decls %end %decls%{

 
    using NodeVector = std::vector<Ast::Node*>;

%}

   

%node Program Node = {
    string_t class_name;
    Node *variable_decls;
    Node *method_decls;
}

%node VariableDeclList Node = {
    Node *first_decl;
    Node *rest_decls;
}

%node VariableDecl Node = {
    Node *type;
    string_t identifier;
    Node *variableDecl_Body;
}

%node VariableDecl_Body Node = {
    Node *ident_list;
}

%node IdentList Node = {
    string_t identifier;
    Node *IdentListParam;
}

%node Type Node = {
    string_t type_name;
    Node *array_optional;
}

%node ArrayOptional Node = {
    int size;
}

%node MethodDeclList Node = {
    Node *first_decl;
    Node *rest_decls;
}

%node MethodDecl Node = {
    Node *method_type;
    string_t identifier;
    Node *MethodDecl_Body;
    
}

%node MethodDecl_Body Node = {
    Node *opt_param_decl_list;
    Node *variable_decls;
    Node *stmt_list;
}

%node MethodType Node = {
    string_t type;
}

%node OptParamDeclList Node = {
    Node *first_param;
    Node *rest_params;
}

%node ParamList Node = {
    Node *first_param;
    Node *rest_params;
}

%node ParamDecl Node = {
    Node *ref_optional;
    Node *type;
    string_t identifier;
}

%node RefOptional Node = {
    bool is_ref;
}

%node StmtList Node = {
    Node *first_stmt;
    Node *rest_stmts;
}

%node Stmt Node %abstract

%node AssignStmt Stmt = {
    string_t identifier;
    Node *array_access;
    Node *expression;
}

%node ArrayAccess Node = {
    Node *expression;
}

%node ReturnStmt Stmt = {
    Node *expression;
}

%node IfStmt Stmt = {
    Node *expression;
    Node *block;
    Node *else_optional;
}

%node ElseOptional Node = {
    Node *block;
}

%node Block Node = {
    Node *stmt_list;
}

%node WhileStmt Stmt = {
    Node *expression;
    Node *block;
}

%node CallStmt Stmt = {
    string_t identifier;
    Node *call_param_list;
}

%node CallParamList Node = {
    Node *expression;
    Node *call_param_rest;
}

%node CallParamRest Node = {
    Node *expression;
    Node *call_param_rest;
}

%node PrintStmt Stmt = {
    Node *print_param;
}

%node PrintParam Node = {
    Node *expression;
    string_t string_literal;
}

%node ReadStmt Stmt = {
    string_t identifier;
}

%node BinaryExpr Node %abstract ={
    Node *left;
    Node *right;
}

%node UnaryExpr Node %abstract ={
    Node *expr;
}


%node EqualBoolean BinaryExpr = {}
%node NEqualBoolean BinaryExpr = {}
%node Less_ThanBoolean BinaryExpr = {}
%node Greater_ThanBoolean BinaryExpr = {}
%node LessEqualBoolean BinaryExpr = {}
%node GreaterEqualBoolean BinaryExpr = {}

%node OrBoolean BinaryExpr = {}
%node AndBoolean BinaryExpr = {}

%node UnaryNotBoolean UnaryExpr = {}

%node SumExpr BinaryExpr = {}
%node SubExpr BinaryExpr = {}
%node MulExpr BinaryExpr = {}
%node DivExpr BinaryExpr = {}
%node ModExpr BinaryExpr = {}

%node UnaryAddExpr UnaryExpr = {}
%node UnarySubExpr UnaryExpr = {}

%node Expr Node %abstract 

%node Number Expr = {
    int value;
}

%node Identifier Expr = {
    string_t name;
}

%node ArrayVariable Node = {
    string_t name;
    Node *indexExpr;
}


































%operation %virtual string_t toString(Node *this) = {""}



toString(Program) {
    std::ostringstream os;

 
    os << "Program "
    << class_name <<    
    "(" << variable_decls->toString() 
    << ", " << method_decls->toString() << ")";
    
    return os.str();
}

toString(VariableDeclList) {
   


    if (!first_decl) return "VariableDeclList()";
    std::ostringstream os;
    os << "VariableDeclList(" << first_decl->toString();
    if (rest_decls) os << ", " << rest_decls->toString();
    os << ")";


    return os.str();
}

toString(VariableDecl) {
    std::ostringstream os;
  os << "VARIABLEDECL" ;
    return os.str();
}

toString(VariableDecl_Body) {
    std::ostringstream os;
    os << "VariableDecl_Body(" <<  ")";

    return os.str();
}

toString(IdentList) {
    
    std::ostringstream os;
    os << "IdentList(" <<  ")";
    return os.str();
}

toString(Type) {
    std::ostringstream os;
    os << "Type(" << type_name;
    if (array_optional) os << ", " << array_optional->toString();
    os << ")";
    return os.str();
}

toString(ArrayOptional) {
 
    std::ostringstream os;
    os << "ArrayOptional(" <<  ")";
    return os.str();
}

toString(MethodDeclList) {

    std::ostringstream os;
    os << "MethodDeclList(" << ")";
    return os.str();
}

toString(MethodDecl) {
    std::ostringstream os;
    os << "MethodDecl(" << ")";
    return os.str();
}

toString(MethodDecl_Body) {
    std::ostringstream os;
    os << "MethodDecl_Body(" << ")";
    return os.str();
}

toString(MethodType) {
    return "MethodType()";
}


toString(ParamList) {
    if (first_param) return "ParamList()";
    std::ostringstream os;
    os << "ParamList(" << first_param->toString();
    if (rest_params) os << ", " << rest_params->toString();
    os << ")";
    return os.str();
}

toString(ParamDecl) {
    std::ostringstream os;
    os << "ParamDecl(";
    if (ref_optional) os << ref_optional->toString() << ", ";
    os << type->toString() << ", " << identifier << ")";
    return os.str();
}

toString(RefOptional) {
    return is_ref ? "RefOptional(ref)" : "RefOptional()";
}

toString(StmtList) {
    if (!first_stmt) return "StmtList()";
    std::ostringstream os;
    os << "StmtList(" << first_stmt->toString();
    if (rest_stmts) os << ", " << rest_stmts->toString();
    os << ")";
    return os.str();
}

toString(AssignStmt) {
    std::ostringstream os;
    os << "AssignStmt(" << identifier;
    if (array_access) os << array_access->toString();
    os << ", " << expression->toString() << ")";
    return os.str();
}

toString(ReturnStmt) {
    return "ReturnStmt(" + expression->toString() + ")";
}

toString(IfStmt) {
    std::ostringstream os;
    os << "IfStmt(" << expression->toString() << ", " << block->toString();
    if (else_optional) os << ", " << else_optional->toString();
    os << ")";
    return os.str();
}

toString(WhileStmt) {
    return "WhileStmt(" + expression->toString() + ", " + block->toString() + ")";
}

toString(CallStmt) {
    std::ostringstream os;
    os << "CallStmt(" << identifier << ", ";
    if (call_param_list) os << call_param_list->toString();
    os << ")";
    return os.str();
}

toString(PrintStmt) {
    return "PrintStmt(" + print_param->toString() + ")";
}




toString(OptParamDeclList) {
    if (!first_param) return "OptParamDeclList()";
    std::ostringstream os;
    os << "OptParamDeclList(" << first_param->toString();
    if (rest_params) os << ", " << rest_params->toString();
    os << ")";
    return os.str();
}

toString(ReadStmt) {
    return "ReadStmt(" + identifier + ")";
}

toString(ArrayAccess) {
    if (!expression) return "ArrayAccess()";
    return "ArrayAccess(" + expression->toString() + ")";
}

toString(ElseOptional) {
    if (!block) return "ElseOptional()";
    return "ElseOptional(" + block->toString() + ")";
}

toString(Block) {
    return "Block(" + stmt_list->toString() + ")";
}


toString(CallParamList) {
  
    return "CallParamList()";
}

toString(CallParamRest) {
  
    return "CallParamRest()";
}

toString(PrintParam) {
    return "PrintParam()";
}



toString(BinaryExpr){
    std::ostringstream os;
    os << "BinaryExpr(" 
       << left->toString() 
       << ", " << right->toString() 
       << ")";
    return os.str();
}


toString(UnaryExpr){
    std::ostringstream os;
    os << "UnaryExpr(" 
       << expr->toString() 
     
       << ")";
    return os.str();
}


toString(EqualBoolean){
    return "EqualBoolean(" + left->toString() + " == " + right->toString() + ")";
}

toString(NEqualBoolean){
    return "NEqualBoolean(" + left->toString() + " != " + right->toString() + ")";
}

toString(Less_ThanBoolean){
    return "Less_ThanBoolean(" + left->toString() + " < " + right->toString() + ")";
}

toString(Greater_ThanBoolean){
    return "Greater_ThanBoolean(" + left->toString() + " > " + right->toString() + ")";
}

toString(LessEqualBoolean){
    return "LessEqualBoolean(" + left->toString() + " <= " + right->toString() + ")";
}

toString(GreaterEqualBoolean){
    return "GreaterEqualBoolean(" + left->toString() + " >= " + right->toString() + ")";
}


toString(OrBoolean){
    return "OrBoolean(" + left->toString() + " || " + right->toString() + ")";
}

toString(AndBoolean){
    return "AndBoolean(" + left->toString() + " && " + right->toString() + ")";
}

toString(UnaryNotBoolean){
    return "UnaryNotBoolean(!" + expr->toString() + ")";
}

toString(SumExpr){
    return "SumExpr(" + left->toString() + " + " + right->toString() + ")";
}

toString(SubExpr){
    return "SubExpr(" + left->toString() + " - " + right->toString() + ")";
}

toString(MulExpr){
    return "MulExpr(" + left->toString() + " * " + right->toString() + ")";
}

toString(DivExpr){
    return "DivExpr(" + left->toString() + " / " + right->toString() + ")";
}

toString(ModExpr){
    return "ModExpr(" + left->toString() + " % " + right->toString() + ")";
}

toString(UnaryAddExpr){
    return "UnaryAddExpr(" + expr->toString() + ")";
}

toString(UnarySubExpr){
    return "UnarySubExpr(-" + expr->toString() + ")";
}

toString(Number){
    std::ostringstream os;
    os << "Number(" << value << ")";
    return os.str();
}

toString(Identifier){
    std::ostringstream os;
    os << "Identifier(" << name << ")";
    return os.str();
}

toString(ArrayVariable){
    std::ostringstream os;
    os << "ArrayVariable(" << name << ", " << indexExpr->toString() << ")";
    return os.str();
}








%operation int eval(Node *node, symbol_table& vars, Method_Table& methodTable, arguments& args, ArrayVariables_Table& arrayvarTable) = {0}




eval(Program) {
    std::cout << "========================================" << std::endl;
    std::cout << "AST Program" << std::endl;

   
    if (node->variable_decls) eval(node->variable_decls, vars, methodTable, args, arrayvarTable);

 
    if (node->method_decls) eval(node->method_decls, vars, methodTable, args, arrayvarTable);

 
    auto mainIt = methodTable.find("main");
    if (mainIt == methodTable.end()) {
        throw std::runtime_error("Main method not found");
    }
   std::cout << "======================MAIN CALL==================" << std::endl;
    Ast::MethodDecl_Body* mainBody = static_cast<Ast::MethodDecl_Body*>(mainIt->second);
    symbol_table mainVars;
    std::vector<int> emptyArgs;
    eval(mainBody, mainVars, methodTable, emptyArgs, arrayvarTable);
   std::cout << "========================================" << std::endl;
    return 0;
}
eval(VariableDeclList) {
    std::cout << "[AST] - VariableDeclList" << std::endl;
    if (node->first_decl)  eval(node->first_decl, vars, methodTable, args, arrayvarTable);

    if (node->rest_decls)  eval(node->rest_decls, vars, methodTable, args, arrayvarTable);

    return 0;
}

eval(VariableDecl) {
    std::cout << "[AST] - VariableDecl" << std::endl;
    Ast::Type* typeNode = dynamic_cast<Ast::Type*>(node->type);
    if (typeNode && typeNode->array_optional) {
        // Se espera que array_optional contenga el tamaño del arreglo.
        int size = eval(typeNode->array_optional, vars, methodTable, args, arrayvarTable);
        std::cout << "->Declarando ARREGLO: " << node->identifier << std::endl;
        arrayvarTable[node->identifier] = std::make_shared<std::vector<std::optional<int>>>(size, std::nullopt);
    } else {
        vars[node->identifier] = 0;
    }
    if (node->variableDecl_Body) {
        eval(node->variableDecl_Body, vars, methodTable, args, arrayvarTable);
    }
    return 0;
}



eval(VariableDecl_Body) {
    std::cout << "[AST] - VariableDecl_Body" << std::endl;
    if (node->ident_list) eval(node->ident_list, vars, methodTable, args, arrayvarTable);
    return 0;
}

eval(IdentList) {
    std::cout << "[AST] - IdentList" << std::endl;
    vars[node->identifier] = 0;
    if (node->IdentListParam) eval(node->IdentListParam, vars, methodTable, args, arrayvarTable);
    return 0;
}

eval(Type) {
    std::cout << "[AST] - Type" << std::endl;
    
    return 0;
}

eval(ArrayOptional) {
    std::cout << "[AST] - ArrayOptional" << std::endl;
    return node->size;
}
eval(MethodDeclList) {
    std::cout << "[AST] - MethodDeclList" << std::endl;
    if (node->first_decl) eval(node->first_decl, vars, methodTable, args, arrayvarTable);
    if (node->rest_decls) eval(node->rest_decls, vars, methodTable, args, arrayvarTable);
    return 0;
}

eval(MethodDecl) {
    std::cout << "[AST] - MethodDecl: " << node->identifier << std::endl;
    methodTable[node->identifier] = node->MethodDecl_Body; // Registrar el método
   
    return 0;
}
eval(MethodDecl_Body) {
    try {
        if (node->opt_param_decl_list)
            eval(node->opt_param_decl_list, vars, methodTable, args, arrayvarTable);
        if (node->variable_decls)
            eval(node->variable_decls, vars, methodTable, args, arrayvarTable);
        return eval(node->stmt_list, vars, methodTable, args, arrayvarTable);
    } catch (const ReturnException& retEx) {
        return retEx.value;
    }
}



eval(MethodType) {
     std::cout << "[AST] - MethodType" << std::endl;
    return 0; 
}

eval(OptParamDeclList) {
     std::cout << "[AST] - OptParamDeclList" << std::endl;
    if (node->first_param)eval(node->first_param, vars, methodTable, args, arrayvarTable);
    if (node->rest_params) eval(node->rest_params, vars, methodTable, args, arrayvarTable);
    return 0;
}

eval(ParamList) {
     std::cout << "[AST] - ParamList" << std::endl;
    if (node->first_param) eval(node->first_param, vars, methodTable, args, arrayvarTable);
    if (node->rest_params) eval(node->rest_params, vars, methodTable, args, arrayvarTable);
    return 0;
}


eval(AssignStmt) {
    std::cout << "[AST] - AssignStmt" << std::endl;
    int value = eval(node->expression, vars, methodTable, args, arrayvarTable);
    
    if (node->array_access) {
        Ast::ArrayAccess* arrayAccess = dynamic_cast<Ast::ArrayAccess*>(node->array_access);
        int index = eval(arrayAccess->expression, vars, methodTable, args, arrayvarTable);
        
        std::cout << "Leyendo Arreglo en Posicion: " << index << std::endl;

        auto it = arrayvarTable.find(node->identifier);
        if (it == arrayvarTable.end()) {
            throw std::runtime_error("Array '" + node->identifier + "' no declarado");
        }
        
        auto& array = *it->second; // Dereferenciar aquí
        if (index < 0 || index >= array.size()) {
            throw std::runtime_error("Índice inválido");
        }
        
        array[index] = value; // Acceso correcto
        std::cout << "Asignando " << value << " en posición " << index << std::endl;
        std::cout << "Array: ";
        for (int i = 0; i < array.size(); i++) {
    if (array[i].has_value()) {
        std::cout << array[i].value() << " ";
    } else {
        std::cout << "null ";
    }
}
        std::cout << std::endl;
   
    } else {
        vars[node->identifier] = value;
    }
    return 0;
}

eval(ReturnStmt) {
    std::cout << "[AST] - ReturnStmt" << std::endl;
    int ret = eval(node->expression, vars, methodTable, args, arrayvarTable);
    throw ReturnException(ret);
}

eval(IfStmt) {
    std::cout << "[AST] - IfStmt" << std::endl;
    
  
    int cond_value = eval(node->expression, vars, methodTable, args, arrayvarTable);
    bool cond = (cond_value != 0);
    std::cout << "Condición: " << cond_value << std::endl;
    if (cond) {
        std::cout << "Condición TRUE" << std::endl;
        return eval(node->block, vars, methodTable, args, arrayvarTable);
    } else if (node->else_optional) {
        std::cout << "Condición FALSE - Ejecutando ELSE" << std::endl;
        return eval(node->else_optional, vars, methodTable, args, arrayvarTable);
    }
    
    return 0; // Retorno por defecto si no hay else
}
eval(WhileStmt) {
    std::cout << "[AST] - WhileStmt" << std::endl;
    int last_val = 0;
    while (true) {  
        int cond_value = eval(node->expression, vars, methodTable, args, arrayvarTable);
        std::cout << "Evaluando condición del while: " << cond_value << std::endl; // Debug
        if (!cond_value) break;  // Si es 0 (false), salir
        last_val = eval(node->block, vars, methodTable, args, arrayvarTable);
    }
    return last_val;
}
eval(ParamDecl) {
    std::cout << "[AST] - ParamDecl" << std::endl;
    Ast::Type* typeNode = dynamic_cast<Ast::Type*>(node->type);
    
    if (typeNode && typeNode->array_optional) {
        // Corrección: Usar el tipo correcto std::optional<int>
        arrayvarTable[node->identifier] = std::make_shared<std::vector<std::optional<int>>>();
    } else {
        vars[node->identifier] = 0;
    }
    return 0;
}
eval(RefOptional) {
     std::cout << "[AST] - RefOptional" << std::endl;
    return node->is_ref; 
}
eval(StmtList) {
   
    if (!node) return 0;
  
    int result = eval(node->first_stmt, vars, methodTable, args, arrayvarTable);
   
    if (node->rest_stmts) {
        result = eval(node->rest_stmts, vars, methodTable, args, arrayvarTable);
    }
    return result;
}
eval(CallStmt) {
    std::cout << "[AST] - CallStmt: " << node->identifier << std::endl;

    // 1. Recolectar argumentos (escalares y arreglos)
    std::vector<int> scalarArgs;  //Argumentos en llamado a funcion func(1,2,3)
    std::vector<std::string> arrayArgs;


    Ast::Node* currentParam = node->call_param_list;
    while (currentParam != nullptr) {
        int argValue = 0;
        // Si es un nodo CallParamList
        if (Ast::CallParamList* cpList = dynamic_cast<Ast::CallParamList*>(currentParam)) {
            if (Ast::Identifier* id = dynamic_cast<Ast::Identifier*>(cpList->expression)) {
                std::cout << "Identificador: " << id->name << std::endl;
                if (arrayvarTable.find(id->name) != arrayvarTable.end()) {
                    arrayArgs.push_back(id->name);
                    scalarArgs.push_back(-1); // Marcador para array
                } else {
                    argValue = eval(cpList->expression, vars, methodTable, args, arrayvarTable);
                    scalarArgs.push_back(argValue);
                    arrayArgs.push_back("");
                }
            } else {
                argValue = eval(cpList->expression, vars, methodTable, args, arrayvarTable);
                scalarArgs.push_back(argValue);
                arrayArgs.push_back("");
            }
            currentParam = cpList->call_param_rest;
        }
        // Si es un nodo CallParamRest (estructura alternativa)
        else if (Ast::CallParamRest* cpRest = dynamic_cast<Ast::CallParamRest*>(currentParam)) {
            if (Ast::Identifier* id = dynamic_cast<Ast::Identifier*>(cpRest->expression)) {
                if (arrayvarTable.find(id->name) != arrayvarTable.end()) {
                    arrayArgs.push_back(id->name);
                    scalarArgs.push_back(-1);
                } else {
                    argValue = eval(cpRest->expression, vars, methodTable, args, arrayvarTable);
                    scalarArgs.push_back(argValue);
                    arrayArgs.push_back("");
                }
            } else {
                argValue = eval(cpRest->expression, vars, methodTable, args, arrayvarTable);
                scalarArgs.push_back(argValue);
                arrayArgs.push_back("");
            }
            currentParam = cpRest->call_param_rest;
        } else {
            break;
        }
    }



    // 2. Buscar el método en la tabla de métodos
    auto methodIt = methodTable.find(node->identifier);
    if (methodIt == methodTable.end()) {
        throw std::runtime_error("Método no encontrado: " + node->identifier);
    }
    Ast::MethodDecl_Body* methodBody = static_cast<Ast::MethodDecl_Body*>(methodIt->second);

    // 3. Contar parámetros formales (integrado sin función externa)
    size_t totalParams = 0;  //Lista de parametros en la declaracion de la funcion
    Ast::Node* paramNode = methodBody->opt_param_decl_list;
    while (paramNode != nullptr) {
        if (Ast::OptParamDeclList* optParams = dynamic_cast<Ast::OptParamDeclList*>(paramNode)) {
            if (optParams->first_param) {
                // Si first_param es un ParamDecl, contamos 1
                if (dynamic_cast<Ast::ParamDecl*>(optParams->first_param) != nullptr) {
                    totalParams++;
                }
                // Si es un ParamList, iteramos por la cadena
                else if (Ast::ParamList* paramList = dynamic_cast<Ast::ParamList*>(optParams->first_param)) {
                    while (paramList != nullptr) {
                        if (paramList->first_param)
                            totalParams++;
                        paramList = dynamic_cast<Ast::ParamList*>(paramList->rest_params);
                    }
                }
            }
            paramNode = optParams->rest_params;
        }
        else if (Ast::ParamList* paramList = dynamic_cast<Ast::ParamList*>(paramNode)) {
            while (paramList != nullptr) {
                if (paramList->first_param)
                    totalParams++;
                paramList = dynamic_cast<Ast::ParamList*>(paramList->rest_params);
            }
            break;
        } else {
            break;
        }
    }

    if (totalParams != scalarArgs.size()) {
        throw std::runtime_error("Error en " + node->identifier +
            ": Parámetros esperados = " + std::to_string(totalParams) +
            ", Argumentos recibidos = " + std::to_string(scalarArgs.size()));
    }

    // 4. Configurar el contexto local para el método y vincular los parámetros
    symbol_table newVars;
    ArrayVariables_Table newArrays;

    //Agregar vars dentro de newVars

    for (auto& var : vars) {
        newVars[var.first] = var.second;
    }

    //Agregar arrays dentro de newArrays
    for (auto& array : arrayvarTable) {
        newArrays[array.first] = array.second;
    }


    paramNode = methodBody->opt_param_decl_list;
    size_t scalarIndex = 0;
    size_t arrayIndex = 0;
    while (paramNode != nullptr) {
        if (Ast::OptParamDeclList* optParams = dynamic_cast<Ast::OptParamDeclList*>(paramNode)) {
            // Si first_param es un ParamDecl
            if (Ast::ParamDecl* paramDecl = dynamic_cast<Ast::ParamDecl*>(optParams->first_param)) {
                Ast::Type* paramType = dynamic_cast<Ast::Type*>(paramDecl->type);
                if (paramType && paramType->array_optional) {
                    if (arrayIndex < arrayArgs.size()) {
                        newArrays[paramDecl->identifier] = arrayvarTable[arrayArgs[arrayIndex]];
                        std::cout << "Array vinculado: " << paramDecl->identifier 
                                  << " -> " << arrayArgs[arrayIndex] << std::endl;
                        arrayIndex++;
                    }
                } else {
                    if (scalarIndex < scalarArgs.size()) {
                        newVars[paramDecl->identifier] = scalarArgs[scalarIndex];
                        std::cout << "Parámetro escalar: " << paramDecl->identifier 
                                  << " = " << scalarArgs[scalarIndex] << std::endl;
                        scalarIndex++;
                    }
                }
            }
            // Si first_param es un ParamList, iteramos sobre ella
            else if (Ast::ParamList* paramList = dynamic_cast<Ast::ParamList*>(optParams->first_param)) {
                while (paramList != nullptr) {
                    if (Ast::ParamDecl* paramDecl = dynamic_cast<Ast::ParamDecl*>(paramList->first_param)) {
                        Ast::Type* paramType = dynamic_cast<Ast::Type*>(paramDecl->type);
                        if (paramType && paramType->array_optional) {
                            if (arrayIndex < arrayArgs.size()) {
                                newArrays[paramDecl->identifier] = arrayvarTable[arrayArgs[arrayIndex]];
                                std::cout << "Array vinculado: " << paramDecl->identifier 
                                          << " -> " << arrayArgs[arrayIndex] << std::endl;
                                arrayIndex++;
                            }
                        } else {
                            if (scalarIndex < scalarArgs.size()) {
                                newVars[paramDecl->identifier] = scalarArgs[scalarIndex];
                                std::cout << "Parámetro escalar: " << paramDecl->identifier 
                                          << " = " << scalarArgs[scalarIndex] << std::endl;
                                scalarIndex++;
                            }
                        }
                    }
                    paramList = dynamic_cast<Ast::ParamList*>(paramList->rest_params);
                }
            }
            paramNode = optParams->rest_params;
        }
        else if (Ast::ParamList* paramList = dynamic_cast<Ast::ParamList*>(paramNode)) {
            while (paramList != nullptr) {
                if (Ast::ParamDecl* paramDecl = dynamic_cast<Ast::ParamDecl*>(paramList->first_param)) {
                    Ast::Type* paramType = dynamic_cast<Ast::Type*>(paramDecl->type);
                    if (paramType && paramType->array_optional) {
                        if (arrayIndex < arrayArgs.size()) {
                            newArrays[paramDecl->identifier] = arrayvarTable[arrayArgs[arrayIndex]];
                            std::cout << "Array vinculado: " << paramDecl->identifier 
                                      << " -> " << arrayArgs[arrayIndex] << std::endl;
                            arrayIndex++;
                        }
                    } else {
                        if (scalarIndex < scalarArgs.size()) {
                            newVars[paramDecl->identifier] = scalarArgs[scalarIndex];
                            std::cout << "Parámetro escalar: " << paramDecl->identifier 
                                      << " = " << scalarArgs[scalarIndex] << std::endl;
                            scalarIndex++;
                        }
                    }
                }
                paramList = dynamic_cast<Ast::ParamList*>(paramList->rest_params);
            }
            break;
        } else {
            break;
        }
    }


    // 4.1. Evaluar las declaraciones de variables locales del método
    if (methodBody->variable_decls) {
        eval(methodBody->variable_decls, newVars, methodTable, args, newArrays);
    }

    // 5. Ejecutar el método en el nuevo contexto
    std::vector<int> dummyArgs;
    int result = 0;

   

    try {
        result = eval(methodBody->stmt_list, newVars, methodTable, dummyArgs, newArrays);
    } catch (const ReturnException& retEx) {
        result = retEx.value;
    }
    
    std::cout << "Método " << node->identifier << " retornó: " << result << std::endl;
    return result;
}







eval(PrintStmt) {
     std::cout << "[AST] - PrintStmt" << std::endl;
     if (node->print_param) {
        eval(node->print_param, vars, methodTable, args, arrayvarTable);
    } 
    return 0;
}

eval(PrintParam) {
   
     std::cout << "[AST] - PrintParam" << std::endl;
    if (node->expression) {
       
        std::cout << eval(node->expression, vars, methodTable, args, arrayvarTable)  << std::endl;
    } else {
        std::cout << node->string_literal << std::endl;
    }
    return 0;
}

eval(ReadStmt) {
     std::cout << "[AST] - ReadStmt" << std::endl;
     int value;
    std::cin >> value;
    vars[node->identifier] = value;
    return 0;
      
}

eval(ArrayAccess) {
    std::cout << "[AST] - ArrayAccess" << std::endl;
    // Evaluar la expresión del índice correctamente
    return eval(node->expression, vars, methodTable, args, arrayvarTable); 
}

eval(ElseOptional) {
    std::cout << "[AST] - ElseOptional" << std::endl;
    if (node->block) {
        return eval(node->block, vars, methodTable, args, arrayvarTable); // Retornar valor del bloque "else"
    }
    return 0;
}


eval(Block) {
    std::cout << "[AST] - Block" << std::endl;
    return eval(node->stmt_list, vars, methodTable, args, arrayvarTable); // Retornar resultado del cuerpo del bloque
}
eval(CallParamList) {
    args.push_back(eval(node->expression, vars, methodTable, args, arrayvarTable)); // args es una referencia
    if (node->call_param_rest) {
        eval(node->call_param_rest, vars, methodTable, args, arrayvarTable);
    }
    return 0;
}
eval(CallParamRest) {
    args.push_back(eval(node->expression, vars, methodTable, args, arrayvarTable));
    if (node->call_param_rest) {
        eval(node->call_param_rest, vars, methodTable, args, arrayvarTable);
    }
    return 0;
}









eval(EqualBoolean){
     std::cout << "[AST] - EqualBoolean" << std::endl;
    return eval(node->left, vars, methodTable, args, arrayvarTable) == eval(node->right, vars, methodTable, args, arrayvarTable);
}

eval(NEqualBoolean){
     std::cout << "[AST] - NEqualBoolean" << std::endl;
    return eval(node->left, vars, methodTable, args, arrayvarTable) != eval(node->right, vars, methodTable, args, arrayvarTable);
}

eval(Less_ThanBoolean){
     std::cout << "[AST] - Less_ThanBoolean" << std::endl;
    return eval(node->left, vars, methodTable, args, arrayvarTable) < eval(node->right, vars, methodTable, args, arrayvarTable);
}

eval(Greater_ThanBoolean){
    int left_val = eval(node->left, vars, methodTable, args, arrayvarTable);
    int right_val = eval(node->right, vars, methodTable, args, arrayvarTable);
    std::cout << "Greater_ThanBoolean: " << left_val << " > " << right_val << std::endl; // Debug
    return left_val > right_val ? 1 : 0;
}
eval(LessEqualBoolean){
     std::cout << "[AST] - LessEqualBoolean" << std::endl;

    int res = eval(node->left, vars, methodTable, args, arrayvarTable) <= eval(node->right, vars, methodTable, args, arrayvarTable);
    std::cout << res << std::endl;
    return res;
}

eval(GreaterEqualBoolean){
     std::cout << "[AST] - GreaterEqualBoolean" << std::endl;
    return eval(node->left, vars, methodTable, args, arrayvarTable) >= eval(node->right, vars, methodTable, args, arrayvarTable);
}

eval(OrBoolean ){
     std::cout << "[AST] - OrBoolean" << std::endl;
    return eval(node->left, vars, methodTable, args, arrayvarTable) || eval(node->right, vars, methodTable, args, arrayvarTable);
}

eval(AndBoolean){
     std::cout << "[AST] - AndBoolean" << std::endl;
    return eval(node->left, vars, methodTable, args, arrayvarTable) && eval(node->right, vars, methodTable, args, arrayvarTable);
}

eval(UnaryNotBoolean){
     std::cout << "[AST] - UnaryNotBoolean" << std::endl;
    return !eval(node->expr, vars, methodTable, args, arrayvarTable);
}


eval(SumExpr){
     std::cout << "[AST] - SumExpr" << std::endl;
    return eval(node->left, vars, methodTable, args, arrayvarTable) + eval(node->right, vars, methodTable, args, arrayvarTable);
}

eval(SubExpr){
     std::cout << "[AST] - SubExpr" << std::endl;
    return eval(node->left, vars, methodTable, args, arrayvarTable) - eval(node->right, vars, methodTable, args, arrayvarTable);
}

eval(MulExpr){
     std::cout << "[AST] - MulExpr" << std::endl;
    return eval(node->left, vars, methodTable, args, arrayvarTable) * eval(node->right, vars, methodTable, args, arrayvarTable);
}


eval(DivExpr){
     std::cout << "[AST] - DivExpr" << std::endl;
    auto right = eval(node->right, vars, methodTable, args, arrayvarTable);
    if (right == 0) {
        throw std::runtime_error("División por cero");
    }
    return eval(node->left, vars, methodTable, args, arrayvarTable) / right;
}

eval(ModExpr){
     std::cout << "[AST] - ModExpr" << std::endl;
    return eval(node->left, vars, methodTable, args, arrayvarTable) % eval(node->right, vars, methodTable, args, arrayvarTable);
}

eval(UnaryAddExpr){
     std::cout << "[AST] - UnaryAddExpr" << std::endl;
    return eval(node->expr, vars, methodTable, args, arrayvarTable);
    }

eval(UnarySubExpr){ std::cout << "[AST] - UnarySubExpr" << std::endl;

    return -eval(node->expr, vars, methodTable, args, arrayvarTable);
}

eval(Number){
     std::cout << "[AST] - Number" << std::endl;
    return node->value;
}


eval(Identifier) {
    std::cout << "[AST] - Identifier" << std::endl;

    // Buscar en variables escalares
    auto varIt = vars.find(node->name);
    if (varIt != vars.end()) {
        return varIt->second;
    }
    
    // Si es un array, permitir su uso como argumento (no lanzar error)
    if (arrayvarTable.find(node->name) != arrayvarTable.end()) {
        return 0; // Valor dummy, el manejo real está en CallStmt
    }
    
    throw std::runtime_error("Variable no definida: " + node->name);
}

eval(ArrayVariable) {
    std::cout << "[AST] - ArrayVariable" << std::endl;
    int index = eval(node->indexExpr, vars, methodTable, args, arrayvarTable);
    
    auto it = arrayvarTable.find(node->name);
    if (it == arrayvarTable.end()) {
        throw std::runtime_error("Array '" + node->name + "' no declarado");
    }
    
    auto& array = *it->second;
    if (index < 0 || index >= array.size()) {
        throw std::runtime_error("Índice fuera de rango");
    }
    
    // Verificar si el valor está inicializado
    if (!array[index].has_value()) {
        throw std::runtime_error("Elemento no inicializado en posición " + std::to_string(index));
    }
    
    std::cout << "Leyendo arreglo en posición " << index << ": " << array[index].value() << std::endl;
    std::cout << "Valor en Array: " << array[index].value() << std::endl;

    return array[index].value(); // Extraer el valor int
}




%operation CodegenResult exprCompile(Node* root, symbol_table& vars) = {CodegenResult{} }



exprCompile(Program) {
    // string_t class_name;
    // Node *variable_decls;
    // Node *method_decls;

    CodegenResult r1 = exprCompile(root->variable_decls, vars);

    std::ostringstream os;
    os << "Program("
 

       << root->class_name
       << r1.code;
       
       if(root->variable_decls) {
           CodegenResult r2 = exprCompile(root->variable_decls, vars);
           os << r2.code;
       }

        if(root->method_decls) {
           CodegenResult r2 = exprCompile(root->method_decls, vars);
           os << r2.code;
       }
  
    os  << ")";




    


for(const auto& [lit, tag] : texts){
    int size = lit.size();

       os << "@" << tag << " = private constant [" << size << " x i8] c\"" << lit << "\\00\", align 1\n";
}




    return {os.str(), ""};
}

exprCompile(VariableDeclList) {
    // Node *first_decl;
    // Node *rest_decls;
    std::ostringstream os;
    os << "VariableDeclList(";
    // if(root->first_decl)
        // os << "exprCompile(root->first_decl, vars).code";
    // if(root->rest_decls)
    //     os << "exprCompile(root->rest_decls, vars).code";
    os << ")";
    return {os.str(), ""};
}

exprCompile(VariableDecl) {
    // Node *type;
    // string_t identifier;
    // Node *variableDecl_Body;
    std::ostringstream os;
    os << "VariableDecl("
       << exprCompile(root->type, vars).code
       << root->identifier
       << exprCompile(root->variableDecl_Body, vars).code
       << ")";
    return {os.str(), ""};
}

exprCompile(VariableDecl_Body) {
    // Node *ident_list;
    std::ostringstream os;
    os << "VariableDecl_Body(";
    if(root->ident_list)
        os << exprCompile(root->ident_list, vars).code;
    os << ")";
    return {os.str(), ""};
}

exprCompile(IdentList) {
    // string_t identifier;
    // Node *IdentListParam;
    std::ostringstream os;
    os << "IdentList(" << root->identifier;
    if(root->IdentListParam)
        os << exprCompile(root->IdentListParam, vars).code;
    os << ")";
    return {os.str(), ""};
}

exprCompile(Type) {
    // string_t type_name;
    // Node *array_optional;
    std::ostringstream os;
    os << "Type(" << root->type_name;
    if(root->array_optional)
        os << exprCompile(root->array_optional, vars).code;
    os << ")";
    return {os.str(), ""};
}

exprCompile(ArrayOptional) {
    // int size;
    std::ostringstream os;
    os << "ArrayOptional(" << root->size << ")";
    return {os.str(), ""};
}

exprCompile(MethodDeclList) {
    // Node *first_decl;
    // Node *rest_decls;
    std::ostringstream os;
    os << "MethodDeclList(";
    if(root->first_decl)
        os << exprCompile(root->first_decl, vars).code;
    if(root->rest_decls)
        os << exprCompile(root->rest_decls, vars).code;
    os << ")";
    return {os.str(), ""};
}

exprCompile(MethodDecl) {
    // Node *method_type;
    // string_t identifier;
    // Node *MethodDecl_Body;
    std::ostringstream os;
    os << "MethodDecl("
       << exprCompile(root->method_type, vars).code
       << root->identifier
       << exprCompile(root->MethodDecl_Body, vars).code
       << ")";
    return {os.str(), ""};
}

exprCompile(MethodDecl_Body) {
    // Node *opt_param_decl_list;
    // Node *variable_decls;
    // Node *stmt_list;
    std::ostringstream os;
    os << "MethodDecl_Body(";
    if(root->opt_param_decl_list)
        os << exprCompile(root->opt_param_decl_list, vars).code;
    if(root->variable_decls)
        os << exprCompile(root->variable_decls, vars).code;
    if(root->stmt_list)
        os << exprCompile(root->stmt_list, vars).code;
    os << ")";
    return {os.str(), ""};
}

exprCompile(MethodType) {
    // string_t type;
    std::ostringstream os;
    os << "MethodType(" << root->type << ")";
    return {os.str(), ""};
}

exprCompile(OptParamDeclList) {
    // Node *first_param;
    // Node *rest_params;
    std::ostringstream os;
    os << "OptParamDeclList(";
    if(root->first_param)
        os << exprCompile(root->first_param, vars).code;
    if(root->rest_params)
        os << exprCompile(root->rest_params, vars).code;
    os << ")";
    return {os.str(), ""};
}

exprCompile(ParamList) {
    // Node *first_param;
    // Node *rest_params;
    std::ostringstream os;
    os << "ParamList(";
    if(root->first_param)
        os << exprCompile(root->first_param, vars).code;
    if(root->rest_params)
        os << exprCompile(root->rest_params, vars).code;
    os << ")";
    return {os.str(), ""};
}

exprCompile(ParamDecl) {
    // Node *ref_optional;
    // Node *type;
    // string_t identifier;
    std::ostringstream os;
    os << "ParamDecl(";
    if(root->ref_optional)
        os << exprCompile(root->ref_optional, vars).code;
    os << exprCompile(root->type, vars).code
       << root->identifier
       << ")";
    return {os.str(), ""};
}

exprCompile(AssignStmt) {
    // string_t identifier;
    // Node *array_access;
    // Node *expression;
    std::ostringstream os;
    os << "AssignStmt(" << root->identifier;
    if(root->array_access)
        os << exprCompile(root->array_access, vars).code;
    if(root->expression)
        os << exprCompile(root->expression, vars).code;
    os << ")";
    return {os.str(), ""};
}

exprCompile(ReturnStmt) {
    // Node *expression;
    std::ostringstream os;
    os << "ReturnStmt(";
    if(root->expression)
        os << exprCompile(root->expression, vars).code;
    os << ")";
    return {os.str(), ""};
}

exprCompile(IfStmt) {
    // Node *expression;
    // Node *block;
    // Node *else_optional;
    std::ostringstream os;
    os << "IfStmt(";
    if(root->expression)
        os << exprCompile(root->expression, vars).code;
    if(root->block)
        os << exprCompile(root->block, vars).code;
    if(root->else_optional)
        os << exprCompile(root->else_optional, vars).code;
    os << ")";
    return {os.str(), ""};
}

exprCompile(WhileStmt) {
    // Node *expression;
    // Node *block;
    std::ostringstream os;
    os << "WhileStmt(";
    if(root->expression)
        os << exprCompile(root->expression, vars).code;
    if(root->block)
        os << exprCompile(root->block, vars).code;
    os << ")";
    return {os.str(), ""};
}

exprCompile(RefOptional) {
    // bool is_ref;
    std::ostringstream os;
    os << "RefOptional(" << (root->is_ref ? "true" : "false") << ")";
    return {os.str(), ""};
}

exprCompile(StmtList) {
    // Node *first_stmt;
    // Node *rest_stmts;
    std::ostringstream os;
    os << "StmtList(";
    if(root->first_stmt)
        os << exprCompile(root->first_stmt, vars).code;
    if(root->rest_stmts)
        os << exprCompile(root->rest_stmts, vars).code;
    os << ")";
    return {os.str(), ""};
}

exprCompile(CallStmt) {
    // string_t identifier;
    // Node *call_param_list;
    std::ostringstream os;
    os << "CallStmt(" << root->identifier;
    if(root->call_param_list)
        os << exprCompile(root->call_param_list, vars).code;
    os << ")";
    return {os.str(), ""};
}

exprCompile(PrintStmt) {
    // Node *print_param;
    std::ostringstream os;
    os << "PrintStmt(";
    if(root->print_param)
        os << exprCompile(root->print_param, vars).code;
    os << ")";
    return {os.str(), ""};
}

exprCompile(PrintParam) {
    // Node *expression;
    // string_t string_literal;
    std::ostringstream os;
    os << "PrintParam(";
    if(root->expression)
        os << exprCompile(root->expression, vars).code;
    os << root->string_literal
       << ")";
    return {os.str(), ""};



// Print Literal

// std::ostringstream os;

// auto it - texts.find(root->literal);

// if(it == texts.end()) {
//    os << "call i32 (i8*, ...)* @printf(i8* )";
// } else {
    



}

exprCompile(ReadStmt) {
    // string_t identifier;
    std::ostringstream os;
    os << "ReadStmt(" << root->identifier << ")";
    return {os.str(), ""};
}

exprCompile(ArrayAccess) {
    // Node *expression;
    std::ostringstream os;
    os << "ArrayAccess(";
    if(root->expression)
        os << exprCompile(root->expression, vars).code;
    os << ")";
    return {os.str(), ""};
}

exprCompile(ElseOptional) {
    // Node *block;
    std::ostringstream os;
    os << "ElseOptional(";
    if(root->block)
        os << exprCompile(root->block, vars).code;
    os << ")";
    return {os.str(), ""};
}

exprCompile(Block) {
    // Node *stmt_list;
    std::ostringstream os;
    os << "Block(";
    if(root->stmt_list)
        os << exprCompile(root->stmt_list, vars).code;
    os << ")";
    return {os.str(), ""};
}

exprCompile(CallParamList) {
    // Node *expression;
    // Node *call_param_rest;
    std::ostringstream os;
    os << "CallParamList(";
    if(root->expression)
        os << exprCompile(root->expression, vars).code;
    if(root->call_param_rest)
        os << exprCompile(root->call_param_rest, vars).code;
    os << ")";
    return {os.str(), ""};
}

exprCompile(CallParamRest) {
    // Node *expression;
    // Node *call_param_rest;
    std::ostringstream os;
    os << "CallParamRest(";
    if(root->expression)
        os << exprCompile(root->expression, vars).code;
    if(root->call_param_rest)
        os << exprCompile(root->call_param_rest, vars).code;
    os << ")";
    return {os.str(), ""};
}

exprCompile(EqualBoolean) {
    // Node *left;
    // Node *right;
    std::ostringstream os;
    os << "EqualBoolean(";
    if(root->left)
        os << exprCompile(root->left, vars).code;
    if(root->right)
        os << exprCompile(root->right, vars).code;
    os << ")";
    return {os.str(), ""};
}

exprCompile(NEqualBoolean) {
    // Node *left;
    // Node *right;
    std::ostringstream os;
    os << "NEqualBoolean(";
    if(root->left)
        os << exprCompile(root->left, vars).code;
    if(root->right)
        os << exprCompile(root->right, vars).code;
    os << ")";
    return {os.str(), ""};
}

exprCompile(Less_ThanBoolean) {
    // Node *left;
    // Node *right;
    std::ostringstream os;
    os << "Less_ThanBoolean(";
    if(root->left)
        os << exprCompile(root->left, vars).code;
    if(root->right)
        os << exprCompile(root->right, vars).code;
    os << ")";
    return {os.str(), ""};
}

exprCompile(Greater_ThanBoolean) {
    // Node *left;
    // Node *right;
    std::ostringstream os;
    os << "Greater_ThanBoolean(";
    if(root->left)
        os << exprCompile(root->left, vars).code;
    if(root->right)
        os << exprCompile(root->right, vars).code;
    os << ")";
    return {os.str(), ""};
}

exprCompile(LessEqualBoolean) {
    // Node *left;
    // Node *right;
    std::ostringstream os;
    os << "LessEqualBoolean(";
    if(root->left)
        os << exprCompile(root->left, vars).code;
    if(root->right)
        os << exprCompile(root->right, vars).code;
    os << ")";
    return {os.str(), ""};
}

exprCompile(GreaterEqualBoolean) {
    // Node *left;
    // Node *right;
    std::ostringstream os;
    os << "GreaterEqualBoolean(";
    if(root->left)
        os << exprCompile(root->left, vars).code;
    if(root->right)
        os << exprCompile(root->right, vars).code;
    os << ")";
    return {os.str(), ""};
}

exprCompile(OrBoolean) {
    // Node *left;
    // Node *right;
    std::ostringstream os;
    os << "OrBoolean(";
    if(root->left)
        os << exprCompile(root->left, vars).code;
    if(root->right)
        os << exprCompile(root->right, vars).code;
    os << ")";
    return {os.str(), ""};
}

exprCompile(AndBoolean) {
    // Node *left;
    // Node *right;
    std::ostringstream os;
    os << "AndBoolean(";
    if(root->left)
        os << exprCompile(root->left, vars).code;
    if(root->right)
        os << exprCompile(root->right, vars).code;
    os << ")";
    return {os.str(), ""};
}

exprCompile(UnaryNotBoolean) {
    // Node *expr;
    std::ostringstream os;
    os << "UnaryNotBoolean(";
    if(root->expr)
        os << exprCompile(root->expr, vars).code;
    os << ")";
    return {os.str(), ""};
}

exprCompile(SumExpr) {
    // Node *left;
    // Node *right;
    std::ostringstream os;
    os << "SumExpr(";
    if(root->left)
        os << exprCompile(root->left, vars).code;
    if(root->right)
        os << exprCompile(root->right, vars).code;
    os << ")";
    return {os.str(), ""};
}

exprCompile(SubExpr) {
    // Node *left;
    // Node *right;
    std::ostringstream os;
    os << "SubExpr(";
    if(root->left)
        os << exprCompile(root->left, vars).code;
    if(root->right)
        os << exprCompile(root->right, vars).code;
    os << ")";
    return {os.str(), ""};
}

exprCompile(MulExpr) {
    // Node *left;
    // Node *right;
    std::ostringstream os;
    os << "MulExpr(";
    if(root->left)
        os << exprCompile(root->left, vars).code;
    if(root->right)
        os << exprCompile(root->right, vars).code;
    os << ")";
    return {os.str(), ""};
}

exprCompile(DivExpr) {
    // Node *left;
    // Node *right;
    std::ostringstream os;
    os << "DivExpr(";
    if(root->left)
        os << exprCompile(root->left, vars).code;
    if(root->right)
        os << exprCompile(root->right, vars).code;
    os << ")";
    return {os.str(), ""};
}

exprCompile(ModExpr) {
    // Node *left;
    // Node *right;
    std::ostringstream os;
    os << "ModExpr(";
    if(root->left)
        os << exprCompile(root->left, vars).code;
    if(root->right)
        os << exprCompile(root->right, vars).code;
    os << ")";
    return {os.str(), ""};
}

exprCompile(UnaryAddExpr) {
    // Node *expr;
    std::ostringstream os;
    os << "UnaryAddExpr(";
    if(root->expr)
        os << exprCompile(root->expr, vars).code;
    os << ")";
    return {os.str(), ""};
}

exprCompile(UnarySubExpr) {
    // Node *expr;
    std::ostringstream os;
    os << "UnarySubExpr(";
    if(root->expr)
        os << exprCompile(root->expr, vars).code;
    os << ")";
    return {os.str(), ""};
}

exprCompile(Number) {
    // int value;
    std::ostringstream os;
    os << "Number(" << root->value << ")";
    return {os.str(), ""};
}

exprCompile(Identifier) {
    // string_t name;
    std::ostringstream os;
    os << "Identifier(" << root->name << ")";
    return {os.str(), ""};
}

exprCompile(ArrayVariable) {
    // string_t name;
    // Node *indexExpr;
    std::ostringstream os;
    os << "ArrayVariable(" << root->name;
    if(root->indexExpr)
        os << exprCompile(root->indexExpr, vars).code;
    os << ")";
    return {os.str(), ""};
}
