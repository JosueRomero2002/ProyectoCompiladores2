%option lang = "C++"
%option namespace = "Ast"


%decls%{
    #include <memory>  // Necesario para shared_ptr (posiblemente ya no se use)
    #include <string>
    #include <iostream>
    #include <sstream>
    #include <unordered_map>
    #include <vector>
    #include <optional>
    
    using string_t = std::string;
    struct variables{
        std::string methodIdentifier;
        std::optional<int>  value;
        variables* ref = nullptr;
        bool isArgument = false;
        bool isRef = false;
    };
    
    using symbol_table = std::unordered_map<std::string, variables>;
    using arguments = std::vector<std::string>;
    
    // Declarar primero ArrayVariables_Table

    struct arrayVariables{
        std::string methodIdentifier;
        std::vector<std::optional<int>> values;
        variables* ref = nullptr;
        bool isArgument = false;
       
    };

    using ArrayVariables_Table = std::unordered_map<
    std::string, 
    arrayVariables // Mantener consistencia
    >;

    using Texts_Table = std::unordered_map<std::string, std::string>;


    namespace Ast {
        class Node;
    }
    

    struct methodVariable{
        std::string methodName;
        std::string Type;
        std::vector<std::string> params;
    };

    // Luego Method_Table que lo referencia
    // using Method_Table = std::unordered_map<std::string, Ast::Node*>;
    using Method_Table = std::unordered_map<std::string, methodVariable>;

    struct CodegenResult{
        std::string code;
        std::string place;
        std::vector<Ast::Node*> args;
    };

    
    

%}


%{
    #include "ExprAst.hpp"
    #include "exceptions.hpp"

    

    std::string newVariable(){
        static int index = 0;

        return "t" + std::to_string(index++);
    }

    std::string newLabel(){
        static int index = 0;

        return "L" + std::to_string(index++);
    }


    std::string newFmts(){
        static int index = 0;

        return "@.fmt" + std::to_string(index++);
    }




    


%}

%node Node %abstract %typedef
%decls %end %decls%{

 
    using NodeVector = std::vector<Ast::Node*>;

%}

   

%node Program Node = {
    string_t class_name;
    Node *varmethod_decls;
    Node *method_decls;
}

%node VarMethodDeclList Node = {
    Node *first_decl;
    Node *rest_decls;
}

%node VariableDeclList Node = {
    Node *first_decl;
    Node *rest_decls;
}

%node VariableDecl Node = {
    Node *type;
    string_t identifier;
    Node *variableDecl_Body;
}

%node VariableDecl_Body Node = {
    Node *ident_list;
}

%node IdentList Node = {
    string_t identifier;
    Node *IdentListParam;
}

%node Type Node = {
    string_t type_name;
    Node *array_optional;
}

%node ArrayOptional Node = {
    int size;
}

%node MethodDeclList Node = {
    Node *first_decl;
    Node *rest_decls;
}

%node MethodDecl Node = {
    Node *method_type;
    string_t identifier;
    Node *MethodDecl_Body;
    
}

%node MethodDecl_Body Node = {
    Node *opt_param_decl_list;
    Node *variable_decls;
    Node *stmt_list;
}

%node MethodType Node = {
    string_t type;
}

%node OptParamDeclList Node = {
    Node *first_param;
    Node *rest_params;
}

%node ParamList Node = {
    Node *first_param;
    Node *rest_params;
}

%node ParamDecl Node = {
    Node *ref_optional;
    Node *type;
    string_t identifier;
}

%node RefOptional Node = {
    bool is_ref;
}

%node StmtList Node = {
    Node *first_stmt;
    Node *rest_stmts;
}

%node Stmt Node %abstract

%node AssignStmt Stmt = {
    string_t identifier;
    Node *array_access;
    Node *expression;
}

%node ArrayAccess Node = {
    Node *expression;
}

%node ReturnStmt Stmt = {
    Node *expression;
}

%node IfStmt Stmt = {
    Node *expression;
    Node *block;
    Node *else_optional;
}

%node ElseOptional Node = {
    Node *block;
}

%node Block Node = {
    Node *stmt_list;
}

%node WhileStmt Stmt = {
    Node *expression;
    Node *block;
}

%node CallStmt Stmt = {
    string_t identifier;
    Node *call_param_list;
}




%node CallParamList Node = {
    Node *expression;
    Node *call_param_rest;
}

%node CallParamRest Node = {
    Node *expression;
    Node *call_param_rest;
}

%node PrintStmt Stmt = {
    Node *print_param;
}

%node PrintParam Node = {
    Node *expression;
    string_t string_literal;
}

%node ReadStmt Stmt = {
    string_t identifier;
}

%node BinaryExpr Node %abstract ={
    Node *left;
    Node *right;
}

%node UnaryExpr Node %abstract ={
    Node *expr;
}


%node EqualBoolean BinaryExpr = {}
%node NEqualBoolean BinaryExpr = {}
%node Less_ThanBoolean BinaryExpr = {}
%node Greater_ThanBoolean BinaryExpr = {}
%node LessEqualBoolean BinaryExpr = {}
%node GreaterEqualBoolean BinaryExpr = {}

%node OrBoolean BinaryExpr = {}
%node AndBoolean BinaryExpr = {}

%node UnaryNotBoolean UnaryExpr = {}

%node SumExpr BinaryExpr = {}
%node SubExpr BinaryExpr = {}
%node MulExpr BinaryExpr = {}
%node DivExpr BinaryExpr = {}
%node ModExpr BinaryExpr = {}

%node UnaryAddExpr UnaryExpr = {}
%node UnarySubExpr UnaryExpr = {}

%node Expr Node %abstract 

%node Number Expr = {
    int value;
}

%node Identifier Expr = {
    string_t name;
}

%node ArrayVariable Node = {
    string_t name;
    Node *indexExpr;
}


%node FunctionCall Stmt = {
    string_t identifier;
    Node *call_param_list;
}































%operation %virtual string_t toString(Node *this) = {""}



toString(Program) {
    std::ostringstream os;

 
    os << "Program "
  << ")";
    
    return os.str();
}

toString(VarMethodDeclList){
    if (!first_decl) return "VariableDeclList()";
    std::ostringstream os;
    os << "VariableDeclList(" << first_decl->toString();
    if (rest_decls) os << ", " << rest_decls->toString();
    os << ")";


    return os.str();
}

toString(VariableDeclList) {
   


    if (!first_decl) return "VariableDeclList()";
    std::ostringstream os;
    os << "VariableDeclList(" << first_decl->toString();
    if (rest_decls) os << ", " << rest_decls->toString();
    os << ")";


    return os.str();
}

toString(VariableDecl) {
    std::ostringstream os;
  os << "VARIABLEDECL" ;
    return os.str();
}

toString(VariableDecl_Body) {
    std::ostringstream os;
    os << "VariableDecl_Body(" <<  ")";

    return os.str();
}

toString(IdentList) {
    
    std::ostringstream os;
    os << "IdentList(" <<  ")";
    return os.str();
}

toString(Type) {
    std::ostringstream os;
    os << "Type(" << type_name;
    if (array_optional) os << ", " << array_optional->toString();
    os << ")";
    return os.str();
}

toString(ArrayOptional) {
 
    std::ostringstream os;
    os << "ArrayOptional(" <<  ")";
    return os.str();
}

toString(MethodDeclList) {

    std::ostringstream os;
    os << "MethodDeclList(" << ")";
    return os.str();
}

toString(MethodDecl) {
    std::ostringstream os;
    os << "MethodDecl(" << ")";
    return os.str();
}

toString(MethodDecl_Body) {
    std::ostringstream os;
    os << "MethodDecl_Body(" << ")";
    return os.str();
}

toString(MethodType) {
    return "MethodType()";
}


toString(ParamList) {
    if (first_param) return "ParamList()";
    std::ostringstream os;
    os << "ParamList(" << first_param->toString();
    if (rest_params) os << ", " << rest_params->toString();
    os << ")";
    return os.str();
}

toString(ParamDecl) {
    std::ostringstream os;
    os << "ParamDecl(";
    if (ref_optional) os << ref_optional->toString() << ", ";
    os << type->toString() << ", " << identifier << ")";
    return os.str();
}

toString(RefOptional) {
    return is_ref ? "RefOptional(ref)" : "RefOptional()";
}

toString(StmtList) {
    if (!first_stmt) return "StmtList()";
    std::ostringstream os;
    os << "StmtList(" << first_stmt->toString();
    if (rest_stmts) os << ", " << rest_stmts->toString();
    os << ")";
    return os.str();
}

toString(AssignStmt) {
    std::ostringstream os;
    os << "AssignStmt(" << identifier;
    if (array_access) os << array_access->toString();
    os << ", " << expression->toString() << ")";
    return os.str();
}

toString(ReturnStmt) {
    return "ReturnStmt(" + expression->toString() + ")";
}

toString(IfStmt) {
    std::ostringstream os;
    os << "IfStmt(" << expression->toString() << ", " << block->toString();
    if (else_optional) os << ", " << else_optional->toString();
    os << ")";
    return os.str();
}

toString(WhileStmt) {
    return "WhileStmt(" + expression->toString() + ", " + block->toString() + ")";
}

toString(CallStmt) {
    std::ostringstream os;
    os << "CallStmt(" << identifier << ", ";
    if (call_param_list) os << call_param_list->toString();
    os << ")";
    return os.str();
}

toString(PrintStmt) {
    return "PrintStmt(" + print_param->toString() + ")";
}




toString(OptParamDeclList) {
    if (!first_param) return "OptParamDeclList()";
    std::ostringstream os;
    os << "OptParamDeclList(" << first_param->toString();
    if (rest_params) os << ", " << rest_params->toString();
    os << ")";
    return os.str();
}

toString(ReadStmt) {
    return "ReadStmt(" + identifier + ")";
}

toString(ArrayAccess) {
    if (!expression) return "ArrayAccess()";
    return "ArrayAccess(" + expression->toString() + ")";
}

toString(ElseOptional) {
    if (!block) return "ElseOptional()";
    return "ElseOptional(" + block->toString() + ")";
}

toString(Block) {
    return "Block(" + stmt_list->toString() + ")";
}


toString(CallParamList) {
  
    return "CallParamList()";
}

toString(CallParamRest) {
  
    return "CallParamRest()";
}

toString(PrintParam) {
    return "PrintParam()";
}



toString(BinaryExpr){
    std::ostringstream os;
    os << "BinaryExpr(" 
       << left->toString() 
       << ", " << right->toString() 
       << ")";
    return os.str();
}


toString(UnaryExpr){
    std::ostringstream os;
    os << "UnaryExpr(" 
       << expr->toString() 
     
       << ")";
    return os.str();
}


toString(EqualBoolean){
    return "EqualBoolean(" + left->toString() + " == " + right->toString() + ")";
}

toString(NEqualBoolean){
    return "NEqualBoolean(" + left->toString() + " != " + right->toString() + ")";
}

toString(Less_ThanBoolean){
    return "Less_ThanBoolean(" + left->toString() + " < " + right->toString() + ")";
}

toString(Greater_ThanBoolean){
    return "Greater_ThanBoolean(" + left->toString() + " > " + right->toString() + ")";
}

toString(LessEqualBoolean){
    return "LessEqualBoolean(" + left->toString() + " <= " + right->toString() + ")";
}

toString(GreaterEqualBoolean){
    return "GreaterEqualBoolean(" + left->toString() + " >= " + right->toString() + ")";
}


toString(OrBoolean){
    return "OrBoolean(" + left->toString() + " || " + right->toString() + ")";
}

toString(AndBoolean){
    return "AndBoolean(" + left->toString() + " && " + right->toString() + ")";
}

toString(UnaryNotBoolean){
    return "UnaryNotBoolean(!" + expr->toString() + ")";
}

toString(SumExpr){
    return "SumExpr(" + left->toString() + " + " + right->toString() + ")";
}

toString(SubExpr){
    return "SubExpr(" + left->toString() + " - " + right->toString() + ")";
}

toString(MulExpr){
    return "MulExpr(" + left->toString() + " * " + right->toString() + ")";
}

toString(DivExpr){
    return "DivExpr(" + left->toString() + " / " + right->toString() + ")";
}

toString(ModExpr){
    return "ModExpr(" + left->toString() + " % " + right->toString() + ")";
}

toString(UnaryAddExpr){
    return "UnaryAddExpr(" + expr->toString() + ")";
}

toString(UnarySubExpr){
    return "UnarySubExpr(-" + expr->toString() + ")";
}

toString(Number){
    std::ostringstream os;
    os << "Number(" << value << ")";
    return os.str();
}

toString(Identifier){
    std::ostringstream os;
    os << "Identifier(" << name << ")";
    return os.str();
}

toString(ArrayVariable){
    std::ostringstream os;
    os << "ArrayVariable(" << name << ", " << indexExpr->toString() << ")";
    return os.str();
}
toString(FunctionCall) {
    std::ostringstream os;
    os << "FunctionCall(" << identifier << ", ";
    if (call_param_list) os << call_param_list->toString();
    os << ")";
    return os.str();
}


%operation CodegenResult exprCompile(Node* root, symbol_table& vars, Method_Table& methodTable, arguments& args, ArrayVariables_Table& arrayvarTable, string_t actualmethodName, Texts_Table& textsTable, int paramPos) = {CodegenResult{} }



exprCompile(Program) {
    // string_t class_name;
    // Node *variable_decls;
    // Node *method_decls;

    std::ostringstream os;
    os << "\n\ndeclare i32 @printf(i8*, ...)\n";
    os << "declare i32 @exit(i32)\n";
    // os << "define i32 @main() {\n";
       
    if(root->varmethod_decls) {
         CodegenResult r2 = exprCompile(root->varmethod_decls, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
           os << r2.code << "\n";
        //    os << r2.place;
           std::cout << "SIII HAY METODOS" << std::endl;
    }else{
        std::cout << "NO HAY METODOS" << std::endl;
    }

        
   

    if(root->method_decls) {
        CodegenResult r2 = exprCompile(root->method_decls, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
        os << r2.code;
    }
 

    os << "@.fmt = private constant [4 x i8] c\"%d\\0A\\00\", align 1\n";

    for (const auto& [lit, var] : textsTable) {
        int size = lit.size() + 1;
        os << var << " = private constant [" << size << " x i8] c\"" << lit << "\\00\", align 1\n";
    }

    return { os.str(), "" };
}


exprCompile(VarMethodDeclList){
    // Node *first_decl;   variables 
    // Node *rest_decls;   metodos
    std::ostringstream os;
    std::string NoMethod;
    CodegenResult r;
    // Variables
    Ast::MethodDeclList* Method_DLIST = dynamic_cast<Ast::MethodDeclList*>(root->first_decl);
    Ast::MethodDeclList* Method_DLIST_2 = dynamic_cast<Ast::MethodDeclList*>(root->rest_decls);
  // os << "ITERACION " << "\n";
  CodegenResult r1 =exprCompile(root->first_decl, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
    if(Method_DLIST ){
        std::cout << "ES METOODO ------------ antes de declarar variables" << std::endl;
        // os << "ES METOODO";
        // os << "ret i32 0\n";
        // os << "}\n\n";

        for (const auto& [var, variable] : vars) {
            if (variable.methodIdentifier == actualmethodName) {
                if(variable.methodIdentifier.empty()){ // son globales
                    os << "    @" << var << " = global i32 zeroinitializer\n";
                    // @x = global i32 0 
                }else{
                    os << "    %" << var << " = alloca i32, align 4\n";
                }
               
            }
        }

        for (const auto& [arrVarIdent, arrayVariable] : arrayvarTable) {
            if (arrayVariable.methodIdentifier == actualmethodName) {
                if(arrayVariable.methodIdentifier.empty()){ // son globales
                    os << "    @" << arrVarIdent << " = global ["<< arrayVariable.values.size() <<" x i32] zeroinitializer\n";
                 
                    // @global_array = global [10 x i32] zeroinitializer
                }else{
                    os << "    %" << arrVarIdent << " = alloca i32, align 4\n";
                       // %array = alloca [10 x i32], align 4 
                }
               
            }
        }

    }else{
        std::cout << "ES METOODO ------------ antes de declarar variables" << std::endl;
        NoMethod="";
        for (const auto& [var, variable] : vars) {
            if (variable.methodIdentifier == actualmethodName) {
                if(variable.methodIdentifier.empty()){ // son globales
                    NoMethod  +="    @" +  var + " = global i32 zeroinitializer\n";
                    // @x = global i32 0 
                }else{
                    NoMethod  += "    %" +  var +  " = alloca i32, align 4\n";
                }
               
            }
        }

        for (const auto& [arrVarIdent, arrayVariable] : arrayvarTable) {
            if (arrayVariable.methodIdentifier == actualmethodName) {
                if(arrayVariable.methodIdentifier.empty()){ // son globales
                    NoMethod += "    @" + arrVarIdent +  " = global ["+ std::to_string(arrayVariable.values.size()) +" x i32] zeroinitializer\n";
                 
                    // @global_array = global [10 x i32] zeroinitializer
                }else{
                    NoMethod  += "    %" + arrVarIdent +  " = alloca i32, align 4\n";
                       // %array = alloca [10 x i32], align 4 
                }
               
            }
        }

        
    }
  
    os << r1.code;
   
   
  
   
    if(root->rest_decls){
    os << exprCompile(root->rest_decls, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos).code;
    }


   r.place = NoMethod;
   r.code = os.str();

    return r;
}


exprCompile(VariableDeclList) {
    // Node *first_decl;
    // Node *rest_decls;
    std::ostringstream os;

    if (root->first_decl) {
        CodegenResult r = exprCompile(root->first_decl, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
        os << r.code;
    }
    if (root->rest_decls) {
        CodegenResult r = exprCompile(root->rest_decls, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
        os << r.code;
    }

    return {os.str(), ""};
}

exprCompile(VariableDecl) {
    // Node *type;
    // string_t identifier;
    // Node *variableDecl_Body;
    std::ostringstream os;

    Ast::Type* arrayAccessNode = dynamic_cast<Ast::Type*>(root->type);
    if (arrayAccessNode && arrayAccessNode->array_optional) {
       
        CodegenResult r = exprCompile( arrayAccessNode->array_optional, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
        arrayvarTable[root->identifier + actualmethodName] = {actualmethodName, std::vector<std::optional<int>> (std::stoi(r.code), std::nullopt), nullptr}; 
        std::cout << "ARRAY CREADO" << root->identifier + actualmethodName << std::endl;
    } else {
        vars[root->identifier + actualmethodName] = {actualmethodName, std::nullopt, nullptr};
        
        std::cout << "VARIABLE CREADA" << root->identifier + actualmethodName << std::endl;

    }
    if (root->variableDecl_Body) {
        exprCompile(root->variableDecl_Body, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
    }

 
    

    return {os.str(), ""};
}

exprCompile(VariableDecl_Body) {
    // Node *ident_list;
    std::ostringstream os;
    if(root->ident_list) {
        os << exprCompile(root->ident_list, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos).code;
    }
    return {os.str(), ""};
}

exprCompile(IdentList) {
    // string_t identifier;
    // Node *IdentListParam;
    std::ostringstream os;
    vars[root->identifier + actualmethodName] ={actualmethodName, std::nullopt, nullptr}; 

    if(root->IdentListParam) exprCompile(root->IdentListParam, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
    os << "";
    return {os.str(), ""};
}

exprCompile(Type) {
    // string_t type_name;
    // Node *array_optional;
    std::ostringstream os;
    // os << "Type(" << root->type_name;

    CodegenResult r;
    r.place = "";
    // os << root->type_name;
    if(root->array_optional){
        // os << exprCompile(root->array_optional, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos).code;
        r.place = "arr";
    }
    if(root->type_name == "INT"){
       r.code = " i32";
    }

    
        // os << ")";
    return r;
}

exprCompile(ArrayOptional) {
    // int size;
    std::ostringstream os;
    os << std::to_string(root->size);
    return {os.str(), ""};
}

exprCompile(MethodDeclList) {
    // Node *first_decl;
    // Node *rest_decls;
    std::ostringstream os;
 
    if(root->first_decl)
        os << exprCompile(root->first_decl, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos).code;
    if(root->rest_decls)
        os << exprCompile(root->rest_decls, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos).code;
  
    return {os.str(), ""};
}
exprCompile(MethodDecl) {
    std::ostringstream os;

 

    // Obtener el tipo del método
    CodegenResult r = exprCompile(root->method_type, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
    
    os << "define " << r.code;
    os << "@" << root->identifier;

    // Corrección: Verificar el dynamic_cast
    auto *methodBody = dynamic_cast<MethodDecl_Body*>(root->MethodDecl_Body);
    if (!methodBody) {
        throw std::runtime_error("Invalid method body structure");
    }

    // Extraer parámetros del método
    std::vector<std::string> paramTypes;
    // Node *paramNode = methodBody->opt_param_decl_list;
    // while (paramNode) {
    //     // Verificar tipo antes de acceder
    //     auto *paramDeclList = dynamic_cast<OptParamDeclList*>(paramNode);
    //     if (!paramDeclList) break;

    //     auto *paramDecl = dynamic_cast<ParamDecl*>(paramDeclList->first_param);
    //     if (paramDecl) { // Solo procesar si el cast es válido
    //         CodegenResult paramResult = exprCompile(paramDecl, vars, methodTable, args, arrayvarTable, root->identifier, textsTable, paramPos);
    //         paramTypes.push_back(paramResult.code);
    //     }

    //     paramNode = paramDeclList->rest_params;
    // }

   
    // Buscar el método en la tabla
    auto it = methodTable.find(root->identifier);
    if (it == methodTable.end()) {
        // Insertar el nuevo método en la tabla
        methodVariable newMethod;
        newMethod.methodName = root->identifier;
        newMethod.Type = r.code; // Tipo de retorno
        newMethod.params = paramTypes;

        methodTable[root->identifier] = newMethod;
    } else {
        // Si ya existe y no es main, actualizamos el tipo de retorno
        if (root->identifier != "main") {
            it->second.Type = r.code;
        }
    }

     // Compilar el cuerpo del método
     os << exprCompile(root->MethodDecl_Body, vars, methodTable, args, arrayvarTable, root->identifier, textsTable, paramPos).code;


     
    if (r.code == "i32 ") {
        os << "ret i32 0\n"; //
    }else{
        os << "ret void\n";
    }



    os << "}\n\n";

    return {os.str(), ""};
}




exprCompile(MethodDecl_Body) {
    // Node *opt_param_decl_list;
    // Node *variable_decls;
    // Node *stmt_list;
    std::ostringstream os;
    os << "(";
    if(root->opt_param_decl_list){
         os << exprCompile(root->opt_param_decl_list, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos).code;
    }
    os << ")";
    os << "{" << "\n";
    if(root->variable_decls){
        os << exprCompile(root->variable_decls, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos).code;
        for (const auto& [var, variable] : vars) {
            if (variable.methodIdentifier == actualmethodName && !variable.isArgument) {
                if(variable.methodIdentifier.empty()){ // son globales
                    os << "    @" << var << " = global i32 zeroinitializer\n";
                    // @x = global i32 0 
                }else{
                    os << "    %" << var << " = alloca i32, align 4\n";
                }
               
            }
        }
        for (const auto& [arrVarIdent, arrayVariable] : arrayvarTable) {
            if (arrayVariable.methodIdentifier == actualmethodName && !arrayVariable.isArgument) {
                if(arrayVariable.methodIdentifier.empty()){ // son globales
                    os << "    @" << arrVarIdent << " = global ["<< arrayVariable.values.size() <<" x i32] zeroinitializer\n";
                 
                    // @global_array = global [10 x i32] zeroinitializer
                }else{
                    os << "    %" << arrVarIdent << " = alloca ["<< arrayVariable.values.size() <<" x i32], align 4\n";
                       // %array = alloca [10 x i32], align 4 
                }
               
            }
        }
    }
    if(root->stmt_list)
        os << exprCompile(root->stmt_list, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos).code;
    // os << ")";

    return {os.str(), ""};
}

exprCompile(MethodType) {
    // string_t type;
    std::ostringstream os;
    // os << "MethodType(" << root->type << ")";

    if(root->type == "INT" ){
        os << "i32 ";
    }else if(root->type == "VOID"){
        os << "void ";
    }

    return {os.str(), ""};
}

exprCompile(OptParamDeclList) {
    // Node *first_param;
    // Node *rest_params;
    std::ostringstream os;
    // os << "OptParamDeclList(";
    if(root->first_param){
        os << exprCompile(root->first_param, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos).code;
    }
    if(root->rest_params){
        os << exprCompile(root->rest_params, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos).code;
    }
        // os << ")";
    return {os.str(), ""};
}

exprCompile(ParamDecl) {
    // Node *ref_optional;
    // Node *type;
    // string_t identifier;
    std::ostringstream os;

    
    CodegenResult r2 = exprCompile(root->type, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
    CodegenResult r1;
    r1.code == "";
    os << "i32";
    if(root->ref_optional){
    r1 = exprCompile(root->ref_optional, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
   
    if((r1.code == "true")){
        os <<  "* ";
    }
    }else if (  r2.place != "") {
        os <<  "* ";
    }
    else{
        os <<  " ";
    }
    os << "%";
    os << root->identifier << actualmethodName;

    // Desconocemos el tamano
    if (  r2.place != "") {
    
       std::cout << "ARRAY CREADO" << std::endl;
        // FIX: DESCONOCEMOS EL TAMANHO DEL ARREGLO
        // FIX: POSIBLE SOLUCION MARCAR COMO YA TIENEN VALOR LOS PARAMS
        arrayvarTable[root->identifier + actualmethodName] = {actualmethodName, std::vector<std::optional<int>> (1, 1), nullptr, true}; 
        methodTable[actualmethodName].params.push_back("ARRAY");
    } else {
       
        if((r1.code == "true")){
            methodTable[actualmethodName].params.push_back("REF");
            vars[root->identifier+ actualmethodName] = {actualmethodName, 1, nullptr, true, true}; 
            std::cout << "REF CREADO" << std::endl;
        }else{
            methodTable[actualmethodName].params.push_back("VAR");
            vars[root->identifier+ actualmethodName] = {actualmethodName, 1, nullptr, true, false}; 
        }
        
    }



    
    return {os.str(), ""};
}

exprCompile(ParamList) {
    // Node *first_param;
    // Node *rest_params;
    std::ostringstream os;
    // os << "ParamList(";
    os << ", ";
    if(root->first_param)
        os << exprCompile(root->first_param, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos).code;
   
    if(root->rest_params)
        os << exprCompile(root->rest_params, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos).code;
    // os << ")";
    return {os.str(), ""};
}



exprCompile(AssignStmt) {
    // string_t identifier;
    // Node *array_access;
    // Node *expression;
    std::ostringstream os;
    // os << "AssignStmt(" << root->identifier;
        if(root->array_access){
            auto it_global = arrayvarTable.find( root->identifier);

            if (it_global != arrayvarTable.end()){
                CodegenResult r;
                //Valor a Ingresar
                CodegenResult r2 = exprCompile(root->expression, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
                os << r2.code << "\n";

                // Indice de Arreglo
                CodegenResult r1 = exprCompile(root->array_access, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
                os << r1.code << "\n";
                r.place = newVariable();

                os << "%"<< r.place <<" = getelementptr ["<< it_global->second.values.size()<<" x i32], ["<< it_global->second.values.size()<<" x i32]* @"<< root->identifier <<", i32 0, i32 %"<< r1.place << "\n";
                os << "store i32 %"<< r2.place << ", i32* %"<< r.place << ", align 4" << "\n";

            }else{
            auto it = arrayvarTable.find( root->identifier + actualmethodName);
                if (it == arrayvarTable.end()){
                    throw std::runtime_error("Error (AS): Array '" + root->identifier +actualmethodName + "' not declared.");
                }else{
                    CodegenResult r;
                    //Valor a Ingresar
                    CodegenResult r2 = exprCompile(root->expression, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
                    os << r2.code << "\n";

                    // Indice de Arreglo
                    CodegenResult r1 = exprCompile(root->array_access, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
                    os << r1.code << "\n";
                    r.place = newVariable();

                    os << "%"<< r.place <<" = getelementptr ["<< it->second.values.size()<<" x i32], ["<< it->second.values.size()<<" x i32]* %"<< root->identifier<<actualmethodName <<", i32 0, i32 %"<< r1.place << "\n";
                    os << "store i32 %"<< r2.place << ", i32* %"<< r.place << ", align 4" << "\n";

                }

            }
               

            // ; Obtener dirección de la posición 2 del array global
            // %idx = getelementptr [5 x i32], [5 x i32]* @global_array, i32 0, i32 2

            // ; Almacenar el valor 42 en la posición 2
            // store i32 42, i32* %idx
        }else{
          

            if(root->expression){
                auto it_global = vars.find( root->identifier);

                if (it_global != vars.end()){
                    CodegenResult r = exprCompile(root->expression, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
                    os << r.code << "\n";
        
                    // auto it = vars.find( root->identifier + actualmethodName);
                    if (it_global != vars.end()) it_global->second.value = 1; //Solucion Posible para determinar que tiene un valor
                    os << "store " << "i32 %" << r.place << ", i32* @" << root->identifier << "\n";
                   
                }else{


                CodegenResult r = exprCompile(root->expression, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
                os << r.code << "\n";
    
                auto it = vars.find( root->identifier + actualmethodName);
                if (it != vars.end()) it->second.value = 1; //Solucion Posible para determinar que tiene un valor
                os << "store " << "i32 %" << r.place << ", i32* %" << root->identifier<<actualmethodName << "\n";
               
                
                 }
            }

    
    
    
    }
  
    
        // os << ")";
    return {os.str(), ""};
}

exprCompile(ReturnStmt) {
    // Node *expression;
    std::ostringstream os;
    
    CodegenResult r;
    if(root->expression){
        r = exprCompile(root->expression, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
        os << r.code << "\n";
        os << "ret i32 %" << r.place << "" << "\n";
        r.code = os.str();
    }
    return r;
}

exprCompile(IfStmt) {
    // Node *expression;
    // Node *block;
    // Node *else_optional;
    std::ostringstream os;
    // os << "IfStmt(";
    CodegenResult r;
    CodegenResult rBool = exprCompile(root->expression, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
    // os << "br "<< rBool.place << ""
    
    std::string ifPart_label = newLabel();
    std::string endif_label = newLabel();

    // CodegenResult rTrueBlock
    CodegenResult rTrue;
    if(root->block){
        rTrue = exprCompile(root->block, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
    }

    os << rBool.code << "\n";
    r.place = newVariable();
    os << "%" << r.place << " = icmp ne i32 %" << rBool.place << ", 0\n";
    // %t4 = icmp ne i32 %t2, 0 
    
    if(root->else_optional){

        std::string elsePart_label = newLabel();
        os << "br i1 %" <<  r.place << ", label %" << ifPart_label <<", label %"<< elsePart_label << "\n";
        os << ifPart_label << ":" << "\n";
       
        os << rTrue.code << "\n";
        os << "br label %" << endif_label << "\n";
        os << elsePart_label << ":" << "\n";
        os << exprCompile(root->else_optional, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos).code;
        
        os << "br label %" << endif_label << "\n";
    }else{
        os << "br i1 %" <<  r.place  << ", label %" <<  ifPart_label <<", label %"<< endif_label << "\n";
        os << ifPart_label << ":" << "\n";
       
        os << rTrue.code << "\n";

        os << "br label %" << endif_label << "\n";
    }

    os << endif_label << ":" << "\n";




        // os << ")";
    return {os.str(), ""};
}

exprCompile(WhileStmt) {
    // Node *expression;
    // Node *block;

        std::ostringstream os;
        CodegenResult r;
    
       
        std::string cond_label = newLabel();  
        std::string body_label = newLabel();  
        std::string exit_label = newLabel(); 
    
     
        os << "br label %" << cond_label << "\n";
    
        
        os << cond_label << ":\n";
        
        CodegenResult cond_result = exprCompile(root->expression, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
        os << cond_result.code << "\n";
    
    
        std::string bool_var = newVariable();
        os << "%" << bool_var << " = icmp ne i32 %" << cond_result.place << ", 0\n";
     
        os << "br i1 %" << bool_var << ", label %" << body_label << ", label %" << exit_label << "\n";
   
        os << body_label << ":\n";
     
        CodegenResult body_result = exprCompile(root->block, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
        os << body_result.code << "\n";

        os << "br label %" << cond_label << "\n";
    
     
        os << exit_label << ":\n";
    
        return { os.str(), "" };
    }

exprCompile(RefOptional) {
    // bool is_ref;
    std::ostringstream os;
    os << (root->is_ref ? "true" : "false");
    return {os.str(), ""};
}

exprCompile(StmtList) {
    // Node *first_stmt;
    // Node *rest_stmts;
    std::ostringstream os;

    if(root->first_stmt)
        os << exprCompile(root->first_stmt, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos).code;
    if(root->rest_stmts)
        os << exprCompile(root->rest_stmts, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos).code;

    return {os.str(), ""};
}

exprCompile(CallStmt) {
    std::ostringstream os;

    auto it = methodTable.find(root->identifier);

    if(it == methodTable.end()){
        // FIX: IMPLEMENTAR ERRORES NO HAY METODO CON ESE NONBRE
        throw std::runtime_error("Error: Method '" + root->identifier + "' not declared.");
    }

    std::string methodType = it->second.Type;


    CodegenResult r; 
    CodegenResult r1; 

    arguments argsMethod = it->second.params; 
    std::cout << "Method: " << root->identifier << " Arguments" << std::endl;
    std::cout << "args: " << argsMethod.size() << std::endl;
    for (int i = 0; i < argsMethod.size(); i++) {
        std::cout << "args: " << argsMethod[i] << std::endl;
    }
    paramPos=0;
    args = argsMethod;
    if(root->call_param_list){
        r1 = exprCompile(root->call_param_list, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
 
    }

    std::cout << "CallStmt: " << root->identifier << " Params" << std::endl;
    std::cout << "args: " << args.size() << std::endl;
    std::cout << "args paramPos: " << paramPos << std::endl;
    for (int i = 0; i < args.size(); i++) {
        std::cout << "args: " << args[i] << std::endl;
    }

  
    r.place = newVariable();
    os << r1.code << "\n";
    os <<"call "<< it->second.Type << "@" << root->identifier <<"(";
    // os << TIPO;

    os << r1.place;
    os << ")" << "\n";

    r.code = os.str();
   
    
   
    return r;
}


exprCompile(CallParamList) {
    CodegenResult r;
    // std::vector<std::string> localargs;
    if (root->expression) {
        CodegenResult r1 = exprCompile(root->expression, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
        r.code = r1.code + "\n";
        // Inferir tipo directamente aquí
        std::string argType = "VAR"; // Valor por defecto
        std::string llvmType = "i32 %";
        
        // Caso 1: Es un identificador
        if (auto* ident = dynamic_cast<Identifier*>(root->expression)) {
            // Buscar en tablas de símbolos
            if (arrayvarTable.find(ident->name + actualmethodName) != arrayvarTable.end()) {
                argType = "ARRAY";
                llvmType = "i32* %";
            }
            else if (vars.find(ident->name + actualmethodName) != vars.end()) {
                // FIX DESHABILITADO TEMPORALMENTE
                // if(vars[ident->name].isRef ){
                if(args[paramPos] == "REF"){
                    argType = "REF";
                    llvmType = "i32* %";
                    r1.place = ident->name+ actualmethodName;
                }else{
                    argType = "VAR";
                    llvmType = "i32 %";
                    std::cout << "32B: " << ident->name << std::endl;
                }
                
            
            }
            else {
                throw std::runtime_error("Variable no declarada: " + ident->name);
            }
        }
        // Caso 2: Acceso a array (arr[5])
        else if (dynamic_cast<ArrayVariable*>(root->expression)) {
            argType = "VAR"; // Tratamos elementos de array como valores
            std::string llvmType = "i32 %";
        }

        // Registrar tipo en args
          r.place += llvmType + r1.place;
        // args.push_back(argType);
      

        // Procesar parámetros restantes
        if (root->call_param_rest) {
            CodegenResult r2 = exprCompile(root->call_param_rest, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
            r.code += r2.code;
            r.place += (r.place.empty() ? "" : ", ") + r2.place;
        }
    }

  
    return r;
}

exprCompile(CallParamRest) {
    CodegenResult r;

    if (root->expression) {
        CodegenResult r1 = exprCompile(root->expression, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
        r.code = r1.code;
       

        // Misma lógica de inferencia que en CallParamList
        std::string argType = "VAR";
        std::string llvmType = "i32 %";
        
        if (auto* ident = dynamic_cast<Identifier*>(root->expression)) {
            if (arrayvarTable.find(ident->name + actualmethodName) != arrayvarTable.end()) {
                argType = "ARRAY";
                llvmType = "i32* %";
            }
            else if (vars.find(ident->name+ actualmethodName) != vars.end()) {
                // FIX DESHABILITADO TEMPORALMENTE
                // argType = vars[ident->name].isRef ? "REF" : "VAR";
                // if(vars[ident->name].isRef ){
                if(args[paramPos] == "REF"){
                    argType = "REF";
                    llvmType = "i32* %";
                    r1.place = ident->name+ actualmethodName;
                }else{
                    argType = "VAR";
                    llvmType = "i32 %";
                }
            
            }
            else {
                throw std::runtime_error("Variable no declarada: " + ident->name);
            }
        }
        else if (dynamic_cast<ArrayVariable*>(root->expression)) {
            argType = "VAR";
            llvmType = "i32 %";
        }

        
        r.place += llvmType + r1.place;
    
        // args.push_back(argType);
        paramPos=4;


        if (root->call_param_rest) {
            CodegenResult r2 = exprCompile(root->call_param_rest, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
            r.code += r2.code;
            r.place += (r.place.empty() ? "" : ", ") + r2.place;
        }
    }

    return r;
}


exprCompile(PrintStmt) {
    // Node *print_param;
    std::ostringstream os;
    if(root->print_param){
 
        // os << exprCompile(root->print_param, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos).code;
        CodegenResult r = exprCompile(root->print_param, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
        os << r.code << "\n";
    }
    return {os.str(), ""};
}

// call i32(i8*, ...) @printf(i8* @.fmt, i32 %minVal)

exprCompile(PrintParam) {
    // Node *expression;
    // string_t string_literal;
    std::ostringstream os;

    CodegenResult r;

    if(root->expression){ //es expresion
        CodegenResult r1 = exprCompile(root->expression, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
        os << r1.code << "\n";
        os << "call i32(i8*, ...) @printf(i8* @.fmt, i32 %"<< r1.place <<")";



    }else{ //Es un literal

        auto it = textsTable.find(root->string_literal);

        if(it == textsTable.end()){

            std::string tagt = newFmts();

            textsTable.insert({root->string_literal, tagt});


            os << "call i32(i8*, ...) @printf(i8* "<< tagt <<")";

            // "call i32(i8*, ...) @printf(i8* @.fmt)"
        }else{
            // it.second
            //FIX: FALTA IMPLEMENTAR
        }

   
    }

    r.code = os.str();
    return r;



// Print Literal

// std::ostringstream os;

// auto it - texts.find(root->literal);

// if(it == texts.end()) {
//    os << "call i32 (i8*, ...)* @printf(i8* )";
// } else {
    



}

exprCompile(ReadStmt) {
    // string_t identifier;

        std::ostringstream os;
        std::string varName = root->identifier + actualmethodName;
    

        auto varIt = vars.find(varName+ actualmethodName);
        if (varIt == vars.end()) {
            if (arrayvarTable.find(varName + actualmethodName) != arrayvarTable.end()) {
                throw std::runtime_error("Error: Cannot read into array variable '" + varName + "'.");
            } else {
                throw std::runtime_error("Error: Variable '" + varName + "' not declared.");
            }
        }
    
      
        std::string varPtr;
        if (varIt->second.methodIdentifier.empty()) {
            varPtr = "@" + varName; 
        } else {
            varPtr = "%" + varName;  
        }
    
  
        std::string resultVar = newVariable();
        os << "%" << resultVar << " = call i32 (i8*, ...) @printf("
           << "i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.printf, i32 0, i32 0), "
           << "i32* " << varPtr << ")\n";
    
        return { os.str(), "" };
    }
exprCompile(ArrayAccess) {
    // Node *expression;
    std::ostringstream os;
    
    CodegenResult r;
    if(root->expression){
        r = exprCompile(root->expression, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
    }
    return r;
}

exprCompile(ElseOptional) {
    // Node *block;
    std::ostringstream os;
    // os << "ElseOptional(";
    CodegenResult r = exprCompile(root->block, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
    // os << ")";
    return r;
}

exprCompile(Block) {
    // Node *stmt_list;
    std::ostringstream os;
    // os << "Block(";
    if(root->stmt_list)
        os << exprCompile(root->stmt_list, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos).code;
    // os << ")";
    return {os.str(), ""};
}


exprCompile(EqualBoolean) {
    // Node *left;
    // Node *right;
    std::ostringstream os;

    CodegenResult r;
    CodegenResult r1 = exprCompile(root->left, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
    CodegenResult r2 = exprCompile(root->right, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);

    os << r1.code << "\n";
    os << r2.code << "\n";

    r.place = newVariable();

    os << "%" << r.place << "_1 = icmp eq i32 %" << r1.place << ", %" << r2.place << "\n";
    os << "%" << r.place << " = zext i1 %" << r.place << "_1 to i32"<< "\n";

    r.code = os.str();
    return r;
}

exprCompile(NEqualBoolean) {
    // Node *left;
    // Node *right;
    std::ostringstream os;

    CodegenResult r;
    CodegenResult r1 = exprCompile(root->left, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
    CodegenResult r2 = exprCompile(root->right, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);

    os << r1.code << "\n";
    os << r2.code << "\n";

    r.place = newVariable();

    os << "%" << r.place << "_1 = icmp ne i32 %" << r1.place << ", %" << r2.place << "\n";
    os << "%" << r.place << " = zext i1 %" << r.place << "_1 to i32"<< "\n";

    r.code = os.str();
    return r;
}

exprCompile(Less_ThanBoolean) {
    // Node *left;
    // Node *right;
    std::ostringstream os;

    CodegenResult r;
    CodegenResult r1 = exprCompile(root->left, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
    CodegenResult r2 = exprCompile(root->right, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);

    os << r1.code << "\n";
    os << r2.code << "\n";

    r.place = newVariable();

    os << "%" << r.place << "_1 = icmp slt i32 %" << r1.place << ", %" << r2.place << "\n";
    os << "%" << r.place << " = zext i1 %" << r.place << "_1 to i32"<< "\n";

    r.code = os.str();
    return r;
}

exprCompile(Greater_ThanBoolean) {
    // Node *left;
    // Node *right;
    std::ostringstream os;

    CodegenResult r;
    CodegenResult r1 = exprCompile(root->left, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
    CodegenResult r2 = exprCompile(root->right, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);

    os << r1.code << "\n";
    os << r2.code << "\n";

    r.place = newVariable();

    os << "%" << r.place << "_1 = icmp sgt i32 %" << r1.place << ", %" << r2.place << "\n";
    os << "%" << r.place << " = zext i1 %" << r.place << "_1 to i32"<< "\n";

    r.code = os.str();
    return r;
}

exprCompile(LessEqualBoolean) {
    // Node *left;
    // Node *right;
    std::ostringstream os;

    CodegenResult r;
    CodegenResult r1 = exprCompile(root->left, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
    CodegenResult r2 = exprCompile(root->right, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);

    os << r1.code << "\n";
    os << r2.code << "\n";

    r.place = newVariable();

    os << "%" << r.place << "_1 = icmp sle i32 %" << r1.place << ", %" << r2.place << "\n";
    os << "%" << r.place << " = zext i1 %" << r.place << "_1 to i32"<< "\n";

    r.code = os.str();
    return r;
}

exprCompile(GreaterEqualBoolean) {
    // Node *left;
    // Node *right;
    std::ostringstream os;

    CodegenResult r;
    CodegenResult r1 = exprCompile(root->left, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
    CodegenResult r2 = exprCompile(root->right, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);

    os << r1.code << "\n";
    os << r2.code << "\n";

    r.place = newVariable();

    os << "%" << r.place << "_1 = icmp sge i32 %" << r1.place << ", %" << r2.place << "\n";
    os << "%" << r.place << " = zext i1 %" << r.place << "_1 to i32"<< "\n";

    r.code = os.str();
    return r;
}
exprCompile(OrBoolean) {
     // Node *left;
    // Node *right;
    std::ostringstream os;
    CodegenResult r;

    // Compilar subexpresiones izquierda y derecha
    CodegenResult r1 = exprCompile(root->left, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
    CodegenResult r2 = exprCompile(root->right, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
    
    os << r1.code << "\n";
    os << r2.code << "\n";

   
    r.place = newVariable();
    os << "%" << r.place << " = or i32 %" << r1.place << ", %" << r2.place << "\n";

    r.code = os.str();
    return r;
}

exprCompile(AndBoolean) {
    // Node *left;
    // Node *right;
    std::ostringstream os;
    CodegenResult r;


    CodegenResult r1 = exprCompile(root->left, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
    CodegenResult r2 = exprCompile(root->right, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
    
    os << r1.code << "\n";
    os << r2.code << "\n";

   
    r.place = newVariable();
    os << "%" << r.place << " = and i32 %" << r1.place << ", %" << r2.place << "\n";

    r.code = os.str();
    return r;
}

exprCompile(UnaryNotBoolean) {
    // Node *expr;
    std::ostringstream os;
    CodegenResult r;


    CodegenResult r1 = exprCompile(root->expr, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
    os << r1.code << "\n";

  
    r.place = newVariable();
    os << "%" << r.place << " = xor i32 %" << r1.place << ", 1\n";

    r.code = os.str();
    return r;
}

exprCompile(SumExpr) {
    // Node *left;
    // Node *right;
    std::ostringstream os;
    
    CodegenResult r1 = exprCompile(root->left, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
    CodegenResult r2 = exprCompile(root->right, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
    CodegenResult r;
    r.place = newVariable();

    os << r1.code << "\n";
    os << r2.code << "\n";


    os << "%" << r.place << " = add i32 %" << r1.place <<", %"<< r2.place;
    r.code = os.str();
    return r;
}

exprCompile(SubExpr) {
    // Node *left;
    // Node *right;
    std::ostringstream os;
    
    CodegenResult r1 = exprCompile(root->left, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
    CodegenResult r2 = exprCompile(root->right, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
    CodegenResult r;
    r.place = newVariable();

    os << r1.code << "\n";
    os << r2.code << "\n";



    os << "%" << r.place << " = sub i32 %" << r1.place <<", %"<< r2.place << "\n";
    r.code = os.str();
    return r;
}

exprCompile(MulExpr) {
    // Node *left;
    // Node *right;
    
     std::ostringstream os;
    
    CodegenResult r1 = exprCompile(root->left, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
    CodegenResult r2 = exprCompile(root->right, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
    CodegenResult r;
    r.place = newVariable();

    os << r1.code << "\n";
    os << r2.code << "\n";



    os << "%" << r.place << " = mul i32 %" << r1.place <<", %"<< r2.place << "\n";
    r.code = os.str();
    return r;
}

exprCompile(DivExpr) {
    // Node *left;
    // Node *right;
    std::ostringstream os;
    
    CodegenResult r1 = exprCompile(root->left, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
    CodegenResult r2 = exprCompile(root->right, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
    CodegenResult r;
    r.place = newVariable();

    os << r1.code << "\n";
    os << r2.code << "\n";



    os << "%" << r.place << " = div i32 %" << r1.place <<", %"<< r2.place << "\n";
    r.code = os.str();
    return r;
}

exprCompile(ModExpr) {
    // Node *left;
    // Node *right;
    std::ostringstream os;
    
    CodegenResult r1 = exprCompile(root->left, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
    CodegenResult r2 = exprCompile(root->right, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
    CodegenResult r;
    r.place = newVariable();

    os << r1.code << "\n";
    os << r2.code << "\n";

    os << "%" << r.place << " = srem i32 %" << r1.place <<", %"<< r2.place << "\n";
    r.code = os.str();
    return r;
}

exprCompile(UnaryAddExpr) {
        // Node *expr;
    std::ostringstream os;
    CodegenResult r;


    CodegenResult exprResult = exprCompile(root->expr, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
    
    os << exprResult.code;
    r.place = exprResult.place;

    r.code = os.str();
    return r;
}

exprCompile(UnarySubExpr) {
    // Node *expr;

        std::ostringstream os;
        CodegenResult r;
    
      
        CodegenResult exprResult = exprCompile(root->expr, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
        os << exprResult.code << "\n";
    

        r.place = newVariable();
        os << "%" << r.place << " = sub i32 0, %" << exprResult.place << "\n";
    
        r.code = os.str();
        return r;
}

exprCompile(Number) {
    // int value;
    std::ostringstream os;
    // os << "Number(" << root->value << ")";

    CodegenResult r;

    r.place = newVariable();
    // r.code = std::to_string(root->value);
    os << "%" << r.place << " = add i32 " << root->value << ", 0" << "\n";
    // r.place = std::to_string(root->value);
    // r.code = "%" + r.place + " = i32 " + std::to_string(root->value);
    r.code = os.str();
    return r;
}

exprCompile(Identifier) {
    // string_t name;
    std::ostringstream os;
    CodegenResult r; 
    r.place = newVariable();

    auto it = vars.find(root->name + actualmethodName);
    auto it_global = vars.find(root->name);
    auto itarray = arrayvarTable.find(root->name + actualmethodName);
    // auto itarray_global = arrayvarTable.find(root->name + actualmethodName);

    if (itarray != arrayvarTable.end()) { 
        if(itarray->second.isArgument){

        r.place = root->name + actualmethodName;
        return r;
        }else{
            r.place = root->name + actualmethodName;
            return r;
        }

   
    }

   
    if ( it_global != vars.end() ){
        if (it_global->second.value.has_value()) {
            //FIX HACE OTRO QUE CONSIDERE LOS REFS
            // if( it->second.methodIdentifier.empty()){//es global
            //     os << "%" << r.place << " = load i32, i32* @" << root->name << ", align 4";
            // }else{
            //     os << "%" << r.place << " = load i32, i32* %" << root->name << ", align 4";
            // }

            if( it_global->second.methodIdentifier.empty()){//es global
                
                os << "%" << r.place << " = load i32, i32* @" << root->name  << ", align 4";
            }else{
                os << "%" << r.place << " = load i32, i32* %" << root->name  << ", align 4";
            }
           
        } else {
            // FIX: ERROR TEMPORALY DISABLED
            throw std::runtime_error("Error: Variable '" + root->name+ actualmethodName + "' has no value.");
        }

    }else{

    if (it == vars.end()) { 
        // La variable no existe en la tabla de símbolos
    //FIX: VOLVER A ASIGNAR LOS EXCEPTIONS
         throw std::runtime_error("Error: Variable (ID)'" + root->name + "' not declared.");
    }

    if (it->second.isArgument) {
        // Es un argumento del método actual, se debe acceder de manera distinta
        if(it->second.isRef){
            os << "%" << r.place << " = load i32, i32* %" << root->name << actualmethodName << ", align 4";
        }else{
            // os << "%" << r.place << " = add i32 %" << root->name << ", 0";
            r.place = root->name + actualmethodName;
        }
        r.code = os.str();
        
        return r;
    } 

    if (it == vars.end()) { 
        // La variable no existe en la tabla de símbolos
    //FIX: VOLVER A ASIGNAR LOS EXCEPTIONS
        // throw std::runtime_error("Error: Variable (ID)'" + root->name + "' not declared.");
    } else if (!it->second.methodIdentifier.empty() && it->second.methodIdentifier != actualmethodName) {
        // Existe pero no pertenece al método actual ni es global
        // throw std::runtime_error("Error: Variable '" + root->name + "' is not accessible in the current scope.");
    } else {
        // Existe y es alcanzable
        
        if (it->second.value.has_value()) {
            //FIX HACE OTRO QUE CONSIDERE LOS REFS
            // if( it->second.methodIdentifier.empty()){//es global
            //     os << "%" << r.place << " = load i32, i32* @" << root->name << ", align 4";
            // }else{
            //     os << "%" << r.place << " = load i32, i32* %" << root->name << ", align 4";
            // }

            if( it->second.methodIdentifier.empty()){//es global
                
                os << "%" << r.place << " = load i32, i32* @" << root->name << actualmethodName << ", align 4";
            }else{
                os << "%" << r.place << " = load i32, i32* %" << root->name << actualmethodName << ", align 4";
            }
           
        } else {
            // FIX: ERROR TEMPORALY DISABLED
            throw std::runtime_error("Error: Variable '" + root->name+ actualmethodName + "' has no value.");
        }


    }
}
    // os << "%" << r.place << " = load i32, i32* %" << root->name << ", align 4";
    // vars.insert({ r.place , variables{"", std::nullopt, nullptr}});
    
    r.code = os.str();
    r.place =  r.place;
    return r;
}

exprCompile(ArrayVariable) {
    // string_t name;
    // Node *indexExpr;    array access es el expr que me retorna el indice
    // x[3]

    // %node ArrayAccess Node = {
    //     Node *expression;
    // }

//     ; Escribir un valor en el índice 2
// %idx = getelementptr [10 x i32], [10 x i32]* %array, i32 0, i32 2
// store i32 5, i32* %idx, align 4       ; Guardar el valor 5 en la posición 2

// ; Leer el valor en el índice 2
// %val = load i32, i32* %idx, align 4   ; Cargar el valor almacenado en %idx

    std::ostringstream os;
    CodegenResult r;

    auto it = arrayvarTable.find( root->name+ actualmethodName);
    auto it_global = arrayvarTable.find( root->name);

    if(it_global != arrayvarTable.end()){
        os<< ";ArrayVariable -----------" << "\n"; //COMMENT
        // Indice de Arreglo
        CodegenResult r1 = exprCompile(root->indexExpr, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
        os << r1.code << "\n";
        r.place = newVariable();
        os << "%"<< r.place <<" = getelementptr ["<< it_global->second.values.size()<<" x i32], ["<< it_global->second.values.size()<<" x i32]* @"<< root->name <<", i32 0, i32 %"<< r1.place << "\n";
        std::string index = r.place ; 
        r.place = newVariable();
        os << "%" << r.place << " = load i32, i32* %" << index << ", align 4";
        os<< "\n;FIN - ArrayVariable --------" << "\n"; //COMMENT
        r.code = os.str();
    }else{
    if (it == arrayvarTable.end()){
        throw std::runtime_error("Error: Array '" + root->name+ actualmethodName + "' not declared.");
    }else{

    os<< ";ArrayVariable -----------" << "\n"; //COMMENT
     // Indice de Arreglo
     CodegenResult r1 = exprCompile(root->indexExpr, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
     os << r1.code << "\n";
     r.place = newVariable();
     os << "%"<< r.place <<" = getelementptr ["<< it->second.values.size()<<" x i32], ["<< it->second.values.size()<<" x i32]* %"<< root->name << actualmethodName<<", i32 0, i32 %"<< r1.place << "\n";
     std::string index = r.place ; 
     r.place = newVariable();
     os << "%" << r.place << " = load i32, i32* %" << index << ", align 4";
     os<< "\n;FIN - ArrayVariable --------" << "\n"; //COMMENT
     r.code = os.str();
    }
    }
    return r;
}



exprCompile(FunctionCall) {
    // string_t identifier;
    // Node *call_param_list;
    std::ostringstream os;

    auto it = methodTable.find(root->identifier);

    if(it == methodTable.end()){
        // FIX: IMPLEMENTAR ERRORES NO HAY METODO CON ESE NONBRE
        throw std::runtime_error("Error: Method '" + root->identifier + actualmethodName+ "' not declared.");
    }

    std::string methodType = it->second.Type;


    CodegenResult r; 
    CodegenResult r1; 

    arguments argsMethod = it->second.params; 
    std::cout << "Method: " << root->identifier << " Arguments" << std::endl;
    std::cout << "args: " << argsMethod.size() << std::endl;
    for (int i = 0; i < argsMethod.size(); i++) {
        std::cout << "args: " << argsMethod[i] << std::endl;
    }

    args = argsMethod;
    paramPos=0;
    if(root->call_param_list){
        r1 = exprCompile(root->call_param_list, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable, paramPos);
 
    }

    std::cout << "Function Call: " << root->identifier << " Params" << std::endl;
    std::cout << "args: " << args.size() << std::endl;
    std::cout << "args paramPos: " << paramPos << std::endl;
    for (int i = 0; i < args.size(); i++) {
        std::cout << "args: " << args[i] << std::endl;
    }



  
    r.place = newVariable();
    os << r1.code << "\n";
    os << "%"<< r.place  <<" = call "<< it->second.Type << "@" << root->identifier <<"(";
    // os << TIPO;

    os << r1.place;
    os << ")" << "\n";

    r.code = os.str();
   
    
   
    return r;
}
