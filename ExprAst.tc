%option lang = "C++"
%option namespace = "Ast"


%decls%{
    #include <memory>  // Necesario para shared_ptr (posiblemente ya no se use)
    #include <string>
    #include <iostream>
    #include <sstream>
    #include <unordered_map>
    #include <vector>
    #include <optional>
    
    using string_t = std::string;
    struct variables{
        std::string methodIdentifier;
        std::optional<int>  value;
        variables* ref = nullptr;
        bool isArgument = false;
    };
    
    using symbol_table = std::unordered_map<std::string, variables>;
    using arguments = std::vector<std::string>;
    
    // Declarar primero ArrayVariables_Table

    struct arrayVariables{
        std::string methodIdentifier;
        std::vector<std::optional<int>> values;
        variables* ref = nullptr;
        bool isArgument = false;
    };

    using ArrayVariables_Table = std::unordered_map<
    std::string, 
    arrayVariables // Mantener consistencia
    >;

    using Texts_Table = std::unordered_map<std::string, std::string>;


    namespace Ast {
        class Node;
    }
    

    struct methodVariable{
        std::string methodName;
        std::string Type;
        std::vector<std::string> params;
    };

    // Luego Method_Table que lo referencia
    // using Method_Table = std::unordered_map<std::string, Ast::Node*>;
    using Method_Table = std::unordered_map<std::string, methodVariable>;

    struct CodegenResult{
        std::string code;
        std::string place;
    };
%}


%{
    #include "ExprAst.hpp"
    #include "exceptions.hpp"

    

    std::string newVariable(){
        static int index = 0;

        return "t" + std::to_string(index++);
    }

    std::string newLabel(){
        static int index = 0;

        return "L" + std::to_string(index++);
    }


    std::string newFmts(){
        static int index = 0;

        return "@.fmt" + std::to_string(index++);
    }






%}

%node Node %abstract %typedef
%decls %end %decls%{

 
    using NodeVector = std::vector<Ast::Node*>;

%}

   

%node Program Node = {
    string_t class_name;
    Node *varmethod_decls;
    Node *method_decls;
}

%node VarMethodDeclList Node = {
    Node *first_decl;
    Node *rest_decls;
}

%node VariableDeclList Node = {
    Node *first_decl;
    Node *rest_decls;
}

%node VariableDecl Node = {
    Node *type;
    string_t identifier;
    Node *variableDecl_Body;
}

%node VariableDecl_Body Node = {
    Node *ident_list;
}

%node IdentList Node = {
    string_t identifier;
    Node *IdentListParam;
}

%node Type Node = {
    string_t type_name;
    Node *array_optional;
}

%node ArrayOptional Node = {
    int size;
}

%node MethodDeclList Node = {
    Node *first_decl;
    Node *rest_decls;
}

%node MethodDecl Node = {
    Node *method_type;
    string_t identifier;
    Node *MethodDecl_Body;
    
}

%node MethodDecl_Body Node = {
    Node *opt_param_decl_list;
    Node *variable_decls;
    Node *stmt_list;
}

%node MethodType Node = {
    string_t type;
}

%node OptParamDeclList Node = {
    Node *first_param;
    Node *rest_params;
}

%node ParamList Node = {
    Node *first_param;
    Node *rest_params;
}

%node ParamDecl Node = {
    Node *ref_optional;
    Node *type;
    string_t identifier;
}

%node RefOptional Node = {
    bool is_ref;
}

%node StmtList Node = {
    Node *first_stmt;
    Node *rest_stmts;
}

%node Stmt Node %abstract

%node AssignStmt Stmt = {
    string_t identifier;
    Node *array_access;
    Node *expression;
}

%node ArrayAccess Node = {
    Node *expression;
}

%node ReturnStmt Stmt = {
    Node *expression;
}

%node IfStmt Stmt = {
    Node *expression;
    Node *block;
    Node *else_optional;
}

%node ElseOptional Node = {
    Node *block;
}

%node Block Node = {
    Node *stmt_list;
}

%node WhileStmt Stmt = {
    Node *expression;
    Node *block;
}

%node CallStmt Stmt = {
    string_t identifier;
    Node *call_param_list;
}

%node CallParamList Node = {
    Node *expression;
    Node *call_param_rest;
}

%node CallParamRest Node = {
    Node *expression;
    Node *call_param_rest;
}

%node PrintStmt Stmt = {
    Node *print_param;
}

%node PrintParam Node = {
    Node *expression;
    string_t string_literal;
}

%node ReadStmt Stmt = {
    string_t identifier;
}

%node BinaryExpr Node %abstract ={
    Node *left;
    Node *right;
}

%node UnaryExpr Node %abstract ={
    Node *expr;
}


%node EqualBoolean BinaryExpr = {}
%node NEqualBoolean BinaryExpr = {}
%node Less_ThanBoolean BinaryExpr = {}
%node Greater_ThanBoolean BinaryExpr = {}
%node LessEqualBoolean BinaryExpr = {}
%node GreaterEqualBoolean BinaryExpr = {}

%node OrBoolean BinaryExpr = {}
%node AndBoolean BinaryExpr = {}

%node UnaryNotBoolean UnaryExpr = {}

%node SumExpr BinaryExpr = {}
%node SubExpr BinaryExpr = {}
%node MulExpr BinaryExpr = {}
%node DivExpr BinaryExpr = {}
%node ModExpr BinaryExpr = {}

%node UnaryAddExpr UnaryExpr = {}
%node UnarySubExpr UnaryExpr = {}

%node Expr Node %abstract 

%node Number Expr = {
    int value;
}

%node Identifier Expr = {
    string_t name;
}

%node ArrayVariable Node = {
    string_t name;
    Node *indexExpr;
}


































%operation %virtual string_t toString(Node *this) = {""}



toString(Program) {
    std::ostringstream os;

 
    os << "Program "
  << ")";
    
    return os.str();
}

toString(VarMethodDeclList){
    if (!first_decl) return "VariableDeclList()";
    std::ostringstream os;
    os << "VariableDeclList(" << first_decl->toString();
    if (rest_decls) os << ", " << rest_decls->toString();
    os << ")";


    return os.str();
}

toString(VariableDeclList) {
   


    if (!first_decl) return "VariableDeclList()";
    std::ostringstream os;
    os << "VariableDeclList(" << first_decl->toString();
    if (rest_decls) os << ", " << rest_decls->toString();
    os << ")";


    return os.str();
}

toString(VariableDecl) {
    std::ostringstream os;
  os << "VARIABLEDECL" ;
    return os.str();
}

toString(VariableDecl_Body) {
    std::ostringstream os;
    os << "VariableDecl_Body(" <<  ")";

    return os.str();
}

toString(IdentList) {
    
    std::ostringstream os;
    os << "IdentList(" <<  ")";
    return os.str();
}

toString(Type) {
    std::ostringstream os;
    os << "Type(" << type_name;
    if (array_optional) os << ", " << array_optional->toString();
    os << ")";
    return os.str();
}

toString(ArrayOptional) {
 
    std::ostringstream os;
    os << "ArrayOptional(" <<  ")";
    return os.str();
}

toString(MethodDeclList) {

    std::ostringstream os;
    os << "MethodDeclList(" << ")";
    return os.str();
}

toString(MethodDecl) {
    std::ostringstream os;
    os << "MethodDecl(" << ")";
    return os.str();
}

toString(MethodDecl_Body) {
    std::ostringstream os;
    os << "MethodDecl_Body(" << ")";
    return os.str();
}

toString(MethodType) {
    return "MethodType()";
}


toString(ParamList) {
    if (first_param) return "ParamList()";
    std::ostringstream os;
    os << "ParamList(" << first_param->toString();
    if (rest_params) os << ", " << rest_params->toString();
    os << ")";
    return os.str();
}

toString(ParamDecl) {
    std::ostringstream os;
    os << "ParamDecl(";
    if (ref_optional) os << ref_optional->toString() << ", ";
    os << type->toString() << ", " << identifier << ")";
    return os.str();
}

toString(RefOptional) {
    return is_ref ? "RefOptional(ref)" : "RefOptional()";
}

toString(StmtList) {
    if (!first_stmt) return "StmtList()";
    std::ostringstream os;
    os << "StmtList(" << first_stmt->toString();
    if (rest_stmts) os << ", " << rest_stmts->toString();
    os << ")";
    return os.str();
}

toString(AssignStmt) {
    std::ostringstream os;
    os << "AssignStmt(" << identifier;
    if (array_access) os << array_access->toString();
    os << ", " << expression->toString() << ")";
    return os.str();
}

toString(ReturnStmt) {
    return "ReturnStmt(" + expression->toString() + ")";
}

toString(IfStmt) {
    std::ostringstream os;
    os << "IfStmt(" << expression->toString() << ", " << block->toString();
    if (else_optional) os << ", " << else_optional->toString();
    os << ")";
    return os.str();
}

toString(WhileStmt) {
    return "WhileStmt(" + expression->toString() + ", " + block->toString() + ")";
}

toString(CallStmt) {
    std::ostringstream os;
    os << "CallStmt(" << identifier << ", ";
    if (call_param_list) os << call_param_list->toString();
    os << ")";
    return os.str();
}

toString(PrintStmt) {
    return "PrintStmt(" + print_param->toString() + ")";
}




toString(OptParamDeclList) {
    if (!first_param) return "OptParamDeclList()";
    std::ostringstream os;
    os << "OptParamDeclList(" << first_param->toString();
    if (rest_params) os << ", " << rest_params->toString();
    os << ")";
    return os.str();
}

toString(ReadStmt) {
    return "ReadStmt(" + identifier + ")";
}

toString(ArrayAccess) {
    if (!expression) return "ArrayAccess()";
    return "ArrayAccess(" + expression->toString() + ")";
}

toString(ElseOptional) {
    if (!block) return "ElseOptional()";
    return "ElseOptional(" + block->toString() + ")";
}

toString(Block) {
    return "Block(" + stmt_list->toString() + ")";
}


toString(CallParamList) {
  
    return "CallParamList()";
}

toString(CallParamRest) {
  
    return "CallParamRest()";
}

toString(PrintParam) {
    return "PrintParam()";
}



toString(BinaryExpr){
    std::ostringstream os;
    os << "BinaryExpr(" 
       << left->toString() 
       << ", " << right->toString() 
       << ")";
    return os.str();
}


toString(UnaryExpr){
    std::ostringstream os;
    os << "UnaryExpr(" 
       << expr->toString() 
     
       << ")";
    return os.str();
}


toString(EqualBoolean){
    return "EqualBoolean(" + left->toString() + " == " + right->toString() + ")";
}

toString(NEqualBoolean){
    return "NEqualBoolean(" + left->toString() + " != " + right->toString() + ")";
}

toString(Less_ThanBoolean){
    return "Less_ThanBoolean(" + left->toString() + " < " + right->toString() + ")";
}

toString(Greater_ThanBoolean){
    return "Greater_ThanBoolean(" + left->toString() + " > " + right->toString() + ")";
}

toString(LessEqualBoolean){
    return "LessEqualBoolean(" + left->toString() + " <= " + right->toString() + ")";
}

toString(GreaterEqualBoolean){
    return "GreaterEqualBoolean(" + left->toString() + " >= " + right->toString() + ")";
}


toString(OrBoolean){
    return "OrBoolean(" + left->toString() + " || " + right->toString() + ")";
}

toString(AndBoolean){
    return "AndBoolean(" + left->toString() + " && " + right->toString() + ")";
}

toString(UnaryNotBoolean){
    return "UnaryNotBoolean(!" + expr->toString() + ")";
}

toString(SumExpr){
    return "SumExpr(" + left->toString() + " + " + right->toString() + ")";
}

toString(SubExpr){
    return "SubExpr(" + left->toString() + " - " + right->toString() + ")";
}

toString(MulExpr){
    return "MulExpr(" + left->toString() + " * " + right->toString() + ")";
}

toString(DivExpr){
    return "DivExpr(" + left->toString() + " / " + right->toString() + ")";
}

toString(ModExpr){
    return "ModExpr(" + left->toString() + " % " + right->toString() + ")";
}

toString(UnaryAddExpr){
    return "UnaryAddExpr(" + expr->toString() + ")";
}

toString(UnarySubExpr){
    return "UnarySubExpr(-" + expr->toString() + ")";
}

toString(Number){
    std::ostringstream os;
    os << "Number(" << value << ")";
    return os.str();
}

toString(Identifier){
    std::ostringstream os;
    os << "Identifier(" << name << ")";
    return os.str();
}

toString(ArrayVariable){
    std::ostringstream os;
    os << "ArrayVariable(" << name << ", " << indexExpr->toString() << ")";
    return os.str();
}


%operation CodegenResult exprCompile(Node* root, symbol_table& vars, Method_Table& methodTable, arguments& args, ArrayVariables_Table& arrayvarTable, string_t actualmethodName, Texts_Table& textsTable) = {CodegenResult{} }



exprCompile(Program) {
    // string_t class_name;
    // Node *variable_decls;
    // Node *method_decls;

    std::ostringstream os;
    os << "\n\ndeclare i32 @printf(i8*, ...)\n";
    os << "declare i32 @exit(i32)\n";
    // os << "define i32 @main() {\n";
       
    if(root->varmethod_decls) {
         CodegenResult r2 = exprCompile(root->varmethod_decls, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable);
           os << r2.code;
    }

        
   

    if(root->method_decls) {
        CodegenResult r2 = exprCompile(root->method_decls, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable);
        os << r2.code;
    }
 

    os << "@.fmt = private constant [4 x i8] c\"%d\\0A\\00\", align 1\n";

    for (const auto& [lit, var] : textsTable) {
        int size = lit.size() + 1;
        os << var << " = private constant [" << size << " x i8] c\"" << lit << "\\00\", align 1\n";
    }

    return { os.str(), "" };
}


exprCompile(VarMethodDeclList){
    // Node *first_decl;   variables 
    // Node *rest_decls;   metodos
    std::ostringstream os;

    // Variables
    Ast::MethodDeclList* Method_DLIST = dynamic_cast<Ast::MethodDeclList*>(root->first_decl);

    if(Method_DLIST){
        // os << "ES METOODO";
        // os << "ret i32 0\n";
        // os << "}\n\n";

        for (const auto& [var, variable] : vars) {
            if (variable.methodIdentifier == actualmethodName) {
                if(variable.methodIdentifier.empty()){ // son globales
                    os << "    @" << var << " = global i32, align 4\n";
                    // @x = global i32 0 
                }else{
                    os << "    %" << var << " = alloca i32, align 4\n";
                }
               
            }
        }

        for (const auto& [arrVarIdent, arrayVariable] : arrayvarTable) {
            if (arrayVariable.methodIdentifier == actualmethodName) {
                if(arrayVariable.methodIdentifier.empty()){ // son globales
                    os << "    @" << arrVarIdent << " = global ["<< arrayVariable.values.size() <<" x i32] zeroinitializer\n";
                 
                    // @global_array = global [10 x i32] zeroinitializer
                }else{
                    os << "    %" << arrVarIdent << " = alloca i32, align 4\n";
                       // %array = alloca [10 x i32], align 4 
                }
               
            }
        }

    }
    // os << "ITERACION " << "\n";

    os << exprCompile(root->first_decl, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable).code;
    if(root->rest_decls){
    os << exprCompile(root->rest_decls, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable).code;
    }

    return {os.str(), ""};
}


exprCompile(VariableDeclList) {
    // Node *first_decl;
    // Node *rest_decls;
    std::ostringstream os;

    if (root->first_decl) {
        CodegenResult r = exprCompile(root->first_decl, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable);
        os << r.code;
    }
    if (root->rest_decls) {
        CodegenResult r = exprCompile(root->rest_decls, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable);
        os << r.code;
    }

    return {os.str(), ""};
}

exprCompile(VariableDecl) {
    // Node *type;
    // string_t identifier;
    // Node *variableDecl_Body;
    std::ostringstream os;

    Ast::Type* arrayAccessNode = dynamic_cast<Ast::Type*>(root->type);
    if (arrayAccessNode && arrayAccessNode->array_optional) {
       
        CodegenResult r = exprCompile( arrayAccessNode->array_optional, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable);
        arrayvarTable[root->identifier] = {actualmethodName, std::vector<std::optional<int>> (std::stoi(r.code), std::nullopt), nullptr}; 
    
    } else {
        vars[root->identifier] = {actualmethodName, std::nullopt, nullptr}; 

    }
    if (root->variableDecl_Body) {
        exprCompile(root->variableDecl_Body, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable);
    }

 
    

    return {os.str(), ""};
}

exprCompile(VariableDecl_Body) {
    // Node *ident_list;
    std::ostringstream os;
    if(root->ident_list) {
        os << exprCompile(root->ident_list, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable).code;
    }
    return {os.str(), ""};
}

exprCompile(IdentList) {
    // string_t identifier;
    // Node *IdentListParam;
    std::ostringstream os;
    vars[root->identifier] ={"", std::nullopt, nullptr}; 

    if(root->IdentListParam) exprCompile(root->IdentListParam, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable);
    os << "";
    return {os.str(), ""};
}

exprCompile(Type) {
    // string_t type_name;
    // Node *array_optional;
    std::ostringstream os;
    // os << "Type(" << root->type_name;

    CodegenResult r;
    r.place = "";
    // os << root->type_name;
    if(root->array_optional){
        // os << exprCompile(root->array_optional, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable).code;
        r.place = "";
    }
    if(root->type_name == "INT"){
       r.code = " i32";
    }

    
        // os << ")";
    return r;
}

exprCompile(ArrayOptional) {
    // int size;
    std::ostringstream os;
    os << std::to_string(root->size);
    return {os.str(), ""};
}

exprCompile(MethodDeclList) {
    // Node *first_decl;
    // Node *rest_decls;
    std::ostringstream os;
 
    if(root->first_decl)
        os << exprCompile(root->first_decl, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable).code;
    if(root->rest_decls)
        os << exprCompile(root->rest_decls, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable).code;
  
    return {os.str(), ""};
}

exprCompile(MethodDecl) {
    // Node *method_type;
    // string_t identifier;
    // Node *MethodDecl_Body;
    std::ostringstream os;


    CodegenResult r = exprCompile(root->method_type, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable);
    // os << "define "
    os << "define ";
     os  << r.code;
    //    << root->identifier
    os << "@" << root->identifier;
     os  << exprCompile(root->MethodDecl_Body, vars, methodTable, args, arrayvarTable, root->identifier, textsTable).code;
    //    << ")";

    auto it = methodTable.find( root->identifier);
    if (it == methodTable.end() && root->identifier != "main"){
        // FIX: POSIBLE ERROR CON MAIn
        throw std::runtime_error("Error: Method '" + root->identifier + "' not declared.");
    }else{
        if(root->identifier != "main"){
        it->second.Type = r.code;
    }
    }
   
    if(r.code == "i32 "){
       
    }else{
        os << "ret void" << "\n";
    }

    os << "}" << "\n\n";
       
    return {os.str(), ""};
}

exprCompile(MethodDecl_Body) {
    // Node *opt_param_decl_list;
    // Node *variable_decls;
    // Node *stmt_list;
    std::ostringstream os;
    os << "(";
    if(root->opt_param_decl_list){
         os << exprCompile(root->opt_param_decl_list, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable).code;
    }
    os << ")";
    os << "{" << "\n";
    if(root->variable_decls){
        os << exprCompile(root->variable_decls, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable).code;
        for (const auto& [var, variable] : vars) {
            if (variable.methodIdentifier == actualmethodName && !variable.isArgument) {
                if(variable.methodIdentifier.empty()){ // son globales
                    os << "    @" << var << " = global i32, align 4\n";
                    // @x = global i32 0 
                }else{
                    os << "    %" << var << " = alloca i32, align 4\n";
                }
               
            }
        }
        for (const auto& [arrVarIdent, arrayVariable] : arrayvarTable) {
            if (arrayVariable.methodIdentifier == actualmethodName && !arrayVariable.isArgument) {
                if(arrayVariable.methodIdentifier.empty()){ // son globales
                    os << "    @" << arrVarIdent << " = global ["<< arrayVariable.values.size() <<" x i32] zeroinitializer\n";
                 
                    // @global_array = global [10 x i32] zeroinitializer
                }else{
                    os << "    %" << arrVarIdent << " = alloca ["<< arrayVariable.values.size() <<" x i32], align 4\n";
                       // %array = alloca [10 x i32], align 4 
                }
               
            }
        }
    }
    if(root->stmt_list)
        os << exprCompile(root->stmt_list, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable).code;
    // os << ")";

    return {os.str(), ""};
}

exprCompile(MethodType) {
    // string_t type;
    std::ostringstream os;
    // os << "MethodType(" << root->type << ")";

    if(root->type == "INT" ){
        os << "i32 ";
    }else if(root->type == "VOID"){
        os << "void ";
    }

    return {os.str(), ""};
}

exprCompile(OptParamDeclList) {
    // Node *first_param;
    // Node *rest_params;
    std::ostringstream os;
    // os << "OptParamDeclList(";
    if(root->first_param){
        os << exprCompile(root->first_param, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable).code;
    }
    if(root->rest_params){
        os << exprCompile(root->rest_params, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable).code;
    }
        // os << ")";
    return {os.str(), ""};
}

exprCompile(ParamDecl) {
    // Node *ref_optional;
    // Node *type;
    // string_t identifier;
    std::ostringstream os;

    
    CodegenResult r2 = exprCompile(root->type, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable);
    CodegenResult r1;
    r1.code == "";
    
    if(root->ref_optional){
    r1 = exprCompile(root->ref_optional, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable);
  
    if((r1.code == "true")){
        os <<  "* ";
    }
    }else{
        os <<  " ";
    }
    os << root->identifier;

    // Desconocemos el tamano
    if (  r2.place != "") {
       
        // FIX: DESCONOCEMOS EL TAMANHO DEL ARREGLO
        arrayvarTable[root->identifier] = {actualmethodName, std::vector<std::optional<int>> (1, std::nullopt), nullptr, true}; 
        methodTable[actualmethodName].params.push_back("ARRAY");
    } else {
        vars[root->identifier] = {actualmethodName, std::nullopt, nullptr, true}; 
        if((r1.code == "true")){
            methodTable[actualmethodName].params.push_back("REF");
        }else{
            methodTable[actualmethodName].params.push_back("VAR");
        }
        
    }



    
    return {os.str(), ""};
}

exprCompile(ParamList) {
    // Node *first_param;
    // Node *rest_params;
    std::ostringstream os;
    // os << "ParamList(";
    os << ", ";
    if(root->first_param)
        os << exprCompile(root->first_param, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable).code;
   
    if(root->rest_params)
        os << exprCompile(root->rest_params, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable).code;
    // os << ")";
    return {os.str(), ""};
}



exprCompile(AssignStmt) {
    // string_t identifier;
    // Node *array_access;
    // Node *expression;
    std::ostringstream os;
    // os << "AssignStmt(" << root->identifier;
        if(root->array_access){
           
            auto it = arrayvarTable.find( root->identifier);
                if (it == arrayvarTable.end()){
                    throw std::runtime_error("Error: Array '" + root->identifier + "' not declared.");
                }else{
                    CodegenResult r;
                    //Valor a Ingresar
                    CodegenResult r2 = exprCompile(root->expression, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable);
                    os << r2.code << "\n";

                    // Indice de Arreglo
                    CodegenResult r1 = exprCompile(root->array_access, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable);
                    os << r1.code << "\n";
                    r.place = newVariable();

                    os << "%"<< r.place <<" = getelementptr ["<< it->second.values.size()<<" x i32], ["<< it->second.values.size()<<" x i32]* %"<< root->identifier <<", i32 0, i32 %"<< r1.place << "\n";
                    os << "store i32 %"<< r2.place << ", i32* %"<< r.place << ", align 4" << "\n";

                }
               

            // ; Obtener dirección de la posición 2 del array global
            // %idx = getelementptr [5 x i32], [5 x i32]* @global_array, i32 0, i32 2

            // ; Almacenar el valor 42 en la posición 2
            // store i32 42, i32* %idx
        }
    
    
        if(root->expression){
            CodegenResult r = exprCompile(root->expression, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable);
            os << r.code << "\n";

            auto it = vars.find( root->identifier);
            if (it != vars.end()) it->second.value = 1; //Solucion Posible para determinar que tiene un valor
            os << "store " << "i32 %" << r.place << ", i32* %" << root->identifier << "\n";
           
            
        }
  
    
        // os << ")";
    return {os.str(), ""};
}

exprCompile(ReturnStmt) {
    // Node *expression;
    std::ostringstream os;
    
    CodegenResult r;
    if(root->expression){
        r = exprCompile(root->expression, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable);
        os << r.code << "\n";
        os << "ret i32 %" << r.place << "\n";
        r.code = os.str();
    }
    return r;
}

exprCompile(IfStmt) {
    // Node *expression;
    // Node *block;
    // Node *else_optional;
    std::ostringstream os;
    os << "IfStmt(";
    if(root->expression)
        os << exprCompile(root->expression, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable).code;
    if(root->block)
        os << exprCompile(root->block, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable).code;
    if(root->else_optional)
        os << exprCompile(root->else_optional, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable).code;
    os << ")";
    return {os.str(), ""};
}

exprCompile(WhileStmt) {
    // Node *expression;
    // Node *block;
    std::ostringstream os;
    os << "WhileStmt(";
    if(root->expression)
        os << exprCompile(root->expression, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable).code;
    if(root->block)
        os << exprCompile(root->block, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable).code;
    os << ")";
    return {os.str(), ""};
}

exprCompile(RefOptional) {
    // bool is_ref;
    std::ostringstream os;
    os << (root->is_ref ? "true" : "false");
    return {os.str(), ""};
}

exprCompile(StmtList) {
    // Node *first_stmt;
    // Node *rest_stmts;
    std::ostringstream os;

    if(root->first_stmt)
        os << exprCompile(root->first_stmt, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable).code;
    if(root->rest_stmts)
        os << exprCompile(root->rest_stmts, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable).code;

    return {os.str(), ""};
}

exprCompile(CallStmt) {
    // string_t identifier;
    // Node *call_param_list;
    std::ostringstream os;

    // auto it = methodTable.find(root->identifier);

    // if(it = methodTable.end()){
    //     // FIX: IMPLEMENTAR ERRORES NO HAY METODO CON ESE NONBRE
    // }
    // call void @minimum(i32* %array, i32 10, i32* %pos, i32* %min)

    // "call i32 @Metodo2()"
    CodegenResult r; 

    if(root->call_param_list){
        r = exprCompile(root->call_param_list, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable);
 
    }

    // methodTable[actualmethodName].Type

    auto it = methodTable.find(root->identifier);

    if(it == methodTable.end()){
        // FIX: IMPLEMENTAR ERRORES NO HAY METODO CON ESE NONBRE
    }

    os << r.code;
    os << "call "<< it->second.Type << "@" << root->identifier <<"(";
    // os << TIPO;

    os << r.place;
    os << ")" << "\n";
   
    return {os.str(), ""};
}

exprCompile(PrintStmt) {
    // Node *print_param;
    std::ostringstream os;
    if(root->print_param){
 
        // os << exprCompile(root->print_param, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable).code;
        CodegenResult r = exprCompile(root->print_param, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable);
        os << r.code << "\n";
    }
    return {os.str(), ""};
}

// call i32(i8*, ...) @printf(i8* @.fmt, i32 %minVal)

exprCompile(PrintParam) {
    // Node *expression;
    // string_t string_literal;
    std::ostringstream os;

    CodegenResult r;

    if(root->expression){ //es expresion
        CodegenResult r1 = exprCompile(root->expression, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable);
        os << r1.code << "\n";
        os << "call i32(i8*, ...) @printf(i8* @.fmt, i32 %"<< r1.place <<")";



    }else{ //Es un literal

        auto it = textsTable.find(root->string_literal);

        if(it == textsTable.end()){

            std::string tagt = newFmts();

            textsTable.insert({root->string_literal, tagt});


            os << "call i32(i8*, ...) @printf(i8* "<< tagt <<")";

            // "call i32(i8*, ...) @printf(i8* @.fmt)"
        }else{
            // it.second
            //FIX: FALTA IMPLEMENTAR
        }

   
    }

    r.code = os.str();
    return r;



// Print Literal

// std::ostringstream os;

// auto it - texts.find(root->literal);

// if(it == texts.end()) {
//    os << "call i32 (i8*, ...)* @printf(i8* )";
// } else {
    



}

exprCompile(ReadStmt) {
    // string_t identifier;
    std::ostringstream os;
    os << "ReadStmt(" << root->identifier << ")";
    return {os.str(), ""};
}

exprCompile(ArrayAccess) {
    // Node *expression;
    std::ostringstream os;
    
    CodegenResult r;
    if(root->expression){
        r = exprCompile(root->expression, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable);
    }
    return r;
}

exprCompile(ElseOptional) {
    // Node *block;
    std::ostringstream os;
    os << "ElseOptional(";
    if(root->block)
        os << exprCompile(root->block, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable).code;
    os << ")";
    return {os.str(), ""};
}

exprCompile(Block) {
    // Node *stmt_list;
    std::ostringstream os;
    os << "Block(";
    if(root->stmt_list)
        os << exprCompile(root->stmt_list, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable).code;
    os << ")";
    return {os.str(), ""};
}

exprCompile(CallParamList) {
    // Node *expression;
    // Node *call_param_rest;
    std::ostringstream os;
    CodegenResult r;
    // os << "CallParamList(";
    r.place = "";
    r.code = "";
    if(root->expression){
        CodegenResult r1 = exprCompile(root->expression, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable);
        r.code += r1.code;
        r.place += "%" + r1.place;
    }
     
    if(root->call_param_rest){
       
        CodegenResult r2 = exprCompile(root->call_param_rest, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable);
        r.code += r2.code;
        r.place += r2.place;
    }
        // os << ")";

   


    return r;
}

exprCompile(CallParamRest) {
    // Node *expression;
    // Node *call_param_rest;
    std::ostringstream os;
    CodegenResult r;
    // os << "CallParamRest(";
    r.place += ", ";
    if(root->expression){
        CodegenResult r1 = exprCompile(root->expression, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable);
        r.code += r1.code;
        r.place += "%" + r1.place;
    }
    if(root->call_param_rest){
        CodegenResult r2 = exprCompile(root->call_param_rest, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable);
        r.code += r2.code;
        r.place += r2.place;
    }
      
    // os << ")";
    return r;
}

exprCompile(EqualBoolean) {
    // Node *left;
    // Node *right;
    std::ostringstream os;
    os << "EqualBoolean(";
    if(root->left)
        os << exprCompile(root->left, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable).code;
    if(root->right)
        os << exprCompile(root->right, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable).code;
    os << ")";
    return {os.str(), ""};
}

exprCompile(NEqualBoolean) {
    // Node *left;
    // Node *right;
    std::ostringstream os;
    os << "NEqualBoolean(";
    if(root->left)
        os << exprCompile(root->left, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable).code;
    if(root->right)
        os << exprCompile(root->right, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable).code;
    os << ")";
    return {os.str(), ""};
}

exprCompile(Less_ThanBoolean) {
    // Node *left;
    // Node *right;
    std::ostringstream os;
    os << "Less_ThanBoolean(";
    if(root->left)
        os << exprCompile(root->left, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable).code;
    if(root->right)
        os << exprCompile(root->right, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable).code;
    os << ")";
    return {os.str(), ""};
}

exprCompile(Greater_ThanBoolean) {
    // Node *left;
    // Node *right;
    std::ostringstream os;
    os << "Greater_ThanBoolean(";
    if(root->left)
        os << exprCompile(root->left, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable).code;
    if(root->right)
        os << exprCompile(root->right, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable).code;
    os << ")";
    return {os.str(), ""};
}

exprCompile(LessEqualBoolean) {
    // Node *left;
    // Node *right;
    std::ostringstream os;
    os << "LessEqualBoolean(";
    if(root->left)
        os << exprCompile(root->left, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable).code;
    if(root->right)
        os << exprCompile(root->right, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable).code;
    os << ")";
    return {os.str(), ""};
}

exprCompile(GreaterEqualBoolean) {
    // Node *left;
    // Node *right;
    std::ostringstream os;
    os << "GreaterEqualBoolean(";
    if(root->left)
        os << exprCompile(root->left, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable).code;
    if(root->right)
        os << exprCompile(root->right, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable).code;
    os << ")";
    return {os.str(), ""};
}

exprCompile(OrBoolean) {
    // Node *left;
    // Node *right;
    std::ostringstream os;
    os << "OrBoolean(";
    if(root->left)
        os << exprCompile(root->left, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable).code;
    if(root->right)
        os << exprCompile(root->right, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable).code;
    os << ")";
    return {os.str(), ""};
}

exprCompile(AndBoolean) {
    // Node *left;
    // Node *right;
    std::ostringstream os;
    os << "AndBoolean(";
    if(root->left)
        os << exprCompile(root->left, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable).code;
    if(root->right)
        os << exprCompile(root->right, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable).code;
    os << ")";
    return {os.str(), ""};
}

exprCompile(UnaryNotBoolean) {
    // Node *expr;
    std::ostringstream os;
    os << "UnaryNotBoolean(";
    if(root->expr)
        os << exprCompile(root->expr, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable).code;
    os << ")";
    return {os.str(), ""};
}

exprCompile(SumExpr) {
    // Node *left;
    // Node *right;
    std::ostringstream os;
    
    CodegenResult r1 = exprCompile(root->left, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable);
    CodegenResult r2 = exprCompile(root->right, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable);
    CodegenResult r;
    r.place = newVariable();

    os << r1.code << "\n";
    os << r2.code << "\n";


    os << "%" << r.place << " = add i32 %" << r1.place <<", %"<< r2.place;
    r.code = os.str();
    return r;
}

exprCompile(SubExpr) {
    // Node *left;
    // Node *right;
    std::ostringstream os;
    
    CodegenResult r1 = exprCompile(root->left, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable);
    CodegenResult r2 = exprCompile(root->right, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable);
    CodegenResult r;
    r.place = newVariable();

    os << r1.code << "\n";
    os << r2.code << "\n";



    os << "%" << r.place << " = sub i32 %" << r1.place <<", %"<< r2.place << "\n";
    r.code = os.str();
    return r;
}

exprCompile(MulExpr) {
    // Node *left;
    // Node *right;
    
     std::ostringstream os;
    
    CodegenResult r1 = exprCompile(root->left, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable);
    CodegenResult r2 = exprCompile(root->right, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable);
    CodegenResult r;
    r.place = newVariable();

    os << r1.code << "\n";
    os << r2.code << "\n";



    os << "%" << r.place << " = mul i32 %" << r1.place <<", %"<< r2.place << "\n";
    r.code = os.str();
    return r;
}

exprCompile(DivExpr) {
    // Node *left;
    // Node *right;
    std::ostringstream os;
    
    CodegenResult r1 = exprCompile(root->left, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable);
    CodegenResult r2 = exprCompile(root->right, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable);
    CodegenResult r;
    r.place = newVariable();

    os << r1.code << "\n";
    os << r2.code << "\n";



    os << "%" << r.place << " = div i32 %" << r1.place <<", %"<< r2.place << "\n";
    r.code = os.str();
    return r;
}

exprCompile(ModExpr) {
    // Node *left;
    // Node *right;
    std::ostringstream os;
    
    CodegenResult r1 = exprCompile(root->left, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable);
    CodegenResult r2 = exprCompile(root->right, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable);
    CodegenResult r;
    r.place = newVariable();

    os << r1.code << "\n";
    os << r2.code << "\n";

    os << "%" << r.place << " = mod i32 %" << r1.place <<", %"<< r2.place << "\n";
    r.code = os.str();
    return r;
}

exprCompile(UnaryAddExpr) {
    // Node *expr;
    std::ostringstream os;
    os << "UnaryAddExpr(";
    if(root->expr)
        os << exprCompile(root->expr, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable).code;
    os << ")";
    return {os.str(), ""};
}

exprCompile(UnarySubExpr) {
    // Node *expr;
    std::ostringstream os;
    os << "UnarySubExpr(";
    if(root->expr)
        os << exprCompile(root->expr, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable).code;
    os << ")";
    return {os.str(), ""};
}

exprCompile(Number) {
    // int value;
    std::ostringstream os;
    // os << "Number(" << root->value << ")";

    CodegenResult r;

    r.place = newVariable();
    // r.code = std::to_string(root->value);
    os << "%" << r.place << " = add i32 " << root->value << ", 0" << "\n";
    // r.place = std::to_string(root->value);
    // r.code = "%" + r.place + " = i32 " + std::to_string(root->value);
    r.code = os.str();
    return r;
}

exprCompile(Identifier) {
    // string_t name;
    std::ostringstream os;
    CodegenResult r; 
    r.place = newVariable();

    auto it = vars.find(root->name);

    if (it == vars.end()) { 
        // La variable no existe en la tabla de símbolos
    
        throw std::runtime_error("Error: Variable '" + root->name + "' not declared.");
    } else if (!it->second.methodIdentifier.empty() && it->second.methodIdentifier != actualmethodName) {
        // Existe pero no pertenece al método actual ni es global
        throw std::runtime_error("Error: Variable '" + root->name + "' is not accessible in the current scope.");
    } else {
        // Existe y es alcanzable
        
        if (it->second.value.has_value()) {
          
            if( it->second.methodIdentifier.empty()){//es global
                os << "%" << r.place << " = load i32, i32* @" << root->name << ", align 4";
            }else{
                os << "%" << r.place << " = load i32, i32* %" << root->name << ", align 4";
            }
           
        } else {
            // FIX: ERROR TEMPORALY DISABLED
            throw std::runtime_error("Error: Variable '" + root->name + "' has no value.");
        }


    }

    // os << "%" << r.place << " = load i32, i32* %" << root->name << ", align 4";
    // vars.insert({ r.place , variables{"", std::nullopt, nullptr}});
    
    r.code = os.str();
    r.place =  r.place;
    return r;
}

exprCompile(ArrayVariable) {
    // string_t name;
    // Node *indexExpr;    array access es el expr que me retorna el indice
    // x[3]

    // %node ArrayAccess Node = {
    //     Node *expression;
    // }

//     ; Escribir un valor en el índice 2
// %idx = getelementptr [10 x i32], [10 x i32]* %array, i32 0, i32 2
// store i32 5, i32* %idx, align 4       ; Guardar el valor 5 en la posición 2

// ; Leer el valor en el índice 2
// %val = load i32, i32* %idx, align 4   ; Cargar el valor almacenado en %idx

    std::ostringstream os;
    CodegenResult r;

    auto it = arrayvarTable.find( root->name);
    if (it == arrayvarTable.end()){
        throw std::runtime_error("Error: Array '" + root->name + "' not declared.");
    }else{

    os<< ";ArrayVariable -----------" << "\n"; //COMMENT
     // Indice de Arreglo
     CodegenResult r1 = exprCompile(root->indexExpr, vars, methodTable, args, arrayvarTable, actualmethodName, textsTable);
     os << r1.code << "\n";
     r.place = newVariable();
     os << "%"<< r.place <<" = getelementptr ["<< it->second.values.size()<<" x i32], ["<< it->second.values.size()<<" x i32]* %"<< root->name <<", i32 0, i32 %"<< r1.place << "\n";
     std::string index = r.place; 
     r.place = newVariable();
     os << "%" << r.place << " = load i32, i32* %" << index << ", align 4";
     os<< "\n;FIN - ArrayVariable --------" << "\n"; //COMMENT
     r.code = os.str();
    }

    return r;
}
